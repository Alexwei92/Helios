<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Using the Helios API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Helios_logo_small.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Using the Helios API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#BuildCompile">Building and Compiling Your Own Projects</a><ul><li class="level2"><a href="#DirStruct">Basic Directory Structure</a></li>
<li class="level2"><a href="#BuildDir">Build Directory</a></li>
<li class="level2"><a href="#Source">Main and auxillary .cpp files</a></li>
<li class="level2"><a href="#CMake">CMakeLists.txt File</a></li>
<li class="level2"><a href="#DirScript">New Project Script</a></li>
</ul>
</li>
<li class="level1"><a href="#ContextSect">Context</a></li>
<li class="level1"><a href="#VecTypes">Vector Types</a><ul><li class="level2"><a href="#RGB">R-G-B(-A) color vectors</a></li>
</ul>
</li>
<li class="level1"><a href="#Coord">Coordinate System</a></li>
<li class="level1"><a href="#Geom">Geometry</a><ul><li class="level2"><a href="#PrimitiveTypes">Primitive Types</a></li>
<li class="level2"><a href="#AddingPrims">Adding Primitives</a><ul><li class="level3"><a href="#AddingPatch">Adding Patches</a></li>
<li class="level3"><a href="#AddingTriangle">Adding Triangles</a></li>
<li class="level3"><a href="#AddingVoxel">Adding Voxels</a></li>
</ul>
</li>
<li class="level2"><a href="#PrimTransform">Primitive Transformations</a></li>
<li class="level2"><a href="#PrimProps">Primitive Properties</a></li>
<li class="level2"><a href="#Texture">Texture Mapping</a></li>
<li class="level2"><a href="#TextureColor">Coloring Primitives by Texture Map</a></li>
<li class="level2"><a href="#TextureMask">Masking Primitives by Image Transparency Channel</a></li>
<li class="level2"><a href="#Compound">Compound Objects</a></li>
</ul>
</li>
<li class="level1"><a href="#Data">Data Structures</a><ul><li class="level2"><a href="#PrimData">Primitive Data</a><ul><li class="level3"><a href="#SetPrimData">Setting Primitive Data Values</a></li>
<li class="level3"><a href="#GetPrimData">Getting Primitive Data Values</a></li>
<li class="level3"><a href="#PrimDataHelpers">Primitive Data Query Functions</a></li>
</ul>
</li>
<li class="level2"><a href="#GlobalData">Global Data</a></li>
<li class="level2"><a href="#DataTimeseries">Data Timeseries</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="BuildCompile"></a>
Building and Compiling Your Own Projects</h1>
<h2><a class="anchor" id="DirStruct"></a>
Basic Directory Structure</h2>
<p>Projects that use the Helios API can be located in any directory, and simply need to reference the location of the source code and plug-ins. Typically the project directory contains the following files and directories (see 'samples' directory for examples):</p>
<ul>
<li>
'build' directory. </li>
<li>
.cpp file containing a main() routine, and other auxillary .cpp files. </li>
<li>
CMakeLists.txt file, which is used to generate a makefile (see next section). </li>
<li>
.h header files (optional). </li>
</ul>
<p>A prototypical directory structure for a project folder is given below:</p>
<ul>
<li>
build (directory)  <ul>
<li>
executable  </li>
</ul>
</li>
<li>
CMakeLists.txt  </li>
<li>
main.cpp  </li>
</ul>
<h2><a class="anchor" id="BuildDir"></a>
Build Directory</h2>
<p>It is generally convenient to have a separate directory in which the project is built. This makes it easy to start fresh with a new build, or create multiple builds on different systems. Usually, the build directory is a subdirectory within the project directory (see 'samples' directory for examples).</p>
<h2><a class="anchor" id="Source"></a>
Main and auxillary .cpp files</h2>
<p>Projects using the Helios API must have a file containing a main() program, and can have any number of complimentary routines and files. Generally, the file containing the main program will include the <a class="el" href="_context_8h.html">Context.h</a> header file, and declare the Context class (see Sect. <a class="el" href="_a_p_i.html#ContextSect">Context</a> below).</p>
<h2><a class="anchor" id="CMake"></a>
CMakeLists.txt File</h2>
<p>Projects that use the Helios API are typically built using a CMakeLists.txt file. A prototypical CMakeLists.txt file used for building Helios samples and projects is given in the code sample below. Inputs for the specific case are entered in the top block of code by setting variables (see the CMake 'set' command reference). The user sets the location of the Helios base directory, the name of the executable file, any source or header files, and a list of plug-ins to use (the example below uses the 'visualizer' plug-in).</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> # Helios standard CMakeLists.txt file version 1.2
 #-------- USER INPUTS ---------#</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> #provide the path to Helios base directory, either as an absolut path or a path relative to the location of this file
 set( BASE_DIRECTORY "../.." )</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> #define the name of the executable to be created
 set( EXECUTABLE_NAME "executable" )</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> #provide name of source file(s) (separate multiple file names with semicolon)
 set( SOURCE_FILES "main.cpp" )</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> #specify which plug-ins to use (separate plug-in names with semicolon)
 set( PLUGINS "visualizer" )</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> #-------- MAIN CODE (Don't Modify) ---------#</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> cmake_minimum_required(VERSION 2.4)
 project(helios)</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> SET(CMAKE_CXX_COMPILER_ID "GNU")
 if( CMAKE_CXX_COMPILER_VERSION VERSION_LESS 4.7 )
     SET(CMAKE_CXX_FLAGS "-g -std=c++0x")
 else()
     SET(CMAKE_CXX_FLAGS "-g -std=c++11")   
 endif()</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> if(NOT DEFINED CMAKE_SUPPRESS_DEVELOPER_WARNINGS)
     set(CMAKE_SUPPRESS_DEVELOPER_WARNINGS 1 CACHE INTERNAL "No dev warnings")
 endif()</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> set( EXECUTABLE_NAME_EXT ${EXECUTABLE_NAME}_exe )</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> set( LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib )</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> add_executable( ${EXECUTABLE_NAME_EXT} ${SOURCE_FILES} )</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> add_subdirectory( ${BASE_DIRECTORY}/core "lib" )
 target_link_libraries( ${EXECUTABLE_NAME_EXT} helios)</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> LIST(LENGTH PLUGINS PLUGIN_COUNT)
 message("-- Loading ${PLUGIN_COUNT} plug-ins")
 foreach(PLUGIN ${PLUGINS})
     message("-- loading plug-in ${PLUGIN}")
     add_subdirectory( ${BASE_DIRECTORY}/plugins/${PLUGIN} "plugins/${PLUGIN}" )
     target_link_libraries( ${EXECUTABLE_NAME_EXT} ${PLUGIN} )
 endforeach(PLUGIN)</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> include_directories( "${PLUGIN_INCLUDE_PATHS};${CMAKE_CURRENT_SOURCE_DIRECTORY}" )</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> add_custom_command( TARGET ${EXECUTABLE_NAME_EXT} POST_BUILD COMMAND ${CMAKE_COMMAND} -E rename ${EXECUTABLE_NAME_EXT} ${EXECUTABLE_NAME} )
 </code></pre></div><p>To run the CMakeLists.txt file, which creates a makefile, simply run the command 'cmake', followed by the path to the CMakeLists.txt file. If, as in the examples above, you are currently in the build directory and your CMakeLists.txt file is located one directory up, the CMake build is accomplished through:</p>
<div style="padding:12px;background-color:#D0D0D0 ;line-height:1.4;"> <code> $ cmake .. </code> </div><p>The code can then be compiled by issuing the 'make' command from the build directory, which will produce an executable in the build directory.</p>
<h2><a class="anchor" id="DirScript"></a>
New Project Script</h2>
<p>There is a script in the main Helios directory that can quickly set up a new project called "create_project.sh". First, create a new directory where the project will exist, for example:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>$ mkdir projects/myProject</code></pre></div><p>To set up the new project, run the create_project.sh script, with the input argument of the project directory:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>$ ./create_project.sh projects/myProjects</code></pre></div><p>This will create the CMakeLists.txt file, a main.cpp file template, and an empty build directory.</p>
<p>You can also specify plug-ins as command-line arguments to the create_project.sh script, in which case the script will create a CMakeLists.txt and main.cpp file that are set up to load those plug-ins:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>$ ./create_project.sh projects/myProjects radiation visualizer</code></pre></div><h1><a class="anchor" id="ContextSect"></a>
Context</h1>
<p>The Context is a C++ class that manages data and functions associated with the Helios framework. The functions of the Context are:</p>
<ol>
<li>
Add and manage geometric objects </li>
<li>
Manage data associated with geometric objects and models in general </li>
<li>
Manage inputs and outpus </li>
</ol>
<p>In simplest terms, the Context stores information associated with geometric objects (primitives) and their corresponding data.</p>
<p>In order to use the Context, the following header must be included:</p>
<div style="padding:2px;background-color:#D0D0D0; line-height: 1.2"> <pre><code> #include "Context.h" </code></pre> </div><p>The context is typically created within the main function:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height: 1.2;"> <pre><code> #include "Context.h"</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height: 1.2;"><pre><code> void main(){
    Context context;
 }
</code></pre> </div><p>The Context is usually passed to plugins (see <a class="el" href="_plugins.html">Writing Plugins</a>), which gives them access to geometry and data.</p>
<h1><a class="anchor" id="VecTypes"></a>
Vector Types</h1>
<p>There are several vector types commonly used by the Context and other plugins (see <a class="el" href="_plugins.html">Writing Plugins</a>). These are C++ structures with at least two member variables. Helios vector types are defined by including the header file:</p>
<div style="padding:2px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "helios_vector_types.h" </code></pre> </div><p>Note that this header is included within the '<a class="el" href="_context_8h.html">Context.h</a>' header, so it is not necessary to include both.</p>
<p>Available vector types are detailed below.</p>
<table class="doxtable">
<tr>
<th>Type </th><th>Description </th><th>Data Fields </th><th>Member Functions </th><th>Creation Function  </th></tr>
<tr>
<td><a class="el" href="structhelios_1_1vec2.html">vec2</a> </td><td>2D vector of floats </td><td><a class="el" href="structhelios_1_1vec2.html#a8dda241c2560b203a3b0a479d1c9e12e">x</a>, <a class="el" href="structhelios_1_1vec2.html#ab4afff51f764cbf9bab0949ae067977e">y</a> </td><td><a class="el" href="structhelios_1_1vec2.html#ae24608a468fbdddf210da4d052fb2265">normalize()</a>, <a class="el" href="structhelios_1_1vec2.html#af9d58100adfd4ab0fadab4e04d9e5b7d">magnitude()</a> </td><td><a class="el" href="group__vectors.html#ga34e381a53377fbe8682d89d8a9c24cc5">make_vec2()</a>  </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1vec3.html">vec3</a> </td><td>3D vector of floats </td><td><a class="el" href="structhelios_1_1vec3.html#a80003da235393c031b8561e678a184a1">x</a>, <a class="el" href="structhelios_1_1vec3.html#ac0be54042f7a639c99ea4dce377f9a65">y</a>, <a class="el" href="structhelios_1_1vec3.html#a870c14ca45729f58e8628a050ce38b6f">z</a> </td><td><a class="el" href="structhelios_1_1vec3.html#a3f663c63de632537985d1842caaccb24">normalize()</a>, <a class="el" href="structhelios_1_1vec3.html#a7187eac19e608e01bcedf7bc2f01bafb">magnitude()</a> </td><td><a class="el" href="helios__vector__types_8h.html#a35b1ff50d62c80cf63426e25ee814ca9">make_vec3()</a>  </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1vec4.html">vec4</a> </td><td>4D vector of floats </td><td><a class="el" href="structhelios_1_1vec4.html#a96036e1d3ac15f03190a7bbf74ce0d73">x</a>, <a class="el" href="structhelios_1_1vec4.html#a3dd547e787593c51f07a6ea131bcab8d">y</a>, <a class="el" href="structhelios_1_1vec4.html#a660ee0cf07d74bac3c989ce39e035d3b">z</a>, <a class="el" href="structhelios_1_1vec4.html#a5d4e8add341c4076176aac3574fe0937">w</a> </td><td>none </td><td><a class="el" href="helios__vector__types_8h.html#ab90da9b5ba29d966547fcfe82de87ea5">make_vec4()</a>  </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1int2.html">int2</a> </td><td>2D vector of integers </td><td><a class="el" href="structhelios_1_1int2.html#ae14968ab74816df03efc977bb5d7b9c7">x</a>, <a class="el" href="structhelios_1_1int2.html#a369861259a6061aa4287f954238e1e21">y</a> </td><td>none </td><td><a class="el" href="helios__vector__types_8h.html#a05ad3ecab7f008a6b1ee04b35f227115">make_int2()</a>  </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1int3.html">int3</a> </td><td>3D vector of integers </td><td><a class="el" href="structhelios_1_1int3.html#a1ce8c8391637ea6e33bb30b1d0adfc50">x</a>, <a class="el" href="structhelios_1_1int3.html#aeba3aa4380ec4d9c216f98be95083d5c">y</a>, <a class="el" href="structhelios_1_1int3.html#adb4b47bc05bdb62677200e025e4bf641">z</a> </td><td>none </td><td><a class="el" href="helios__vector__types_8h.html#a88347513c8d7e764d5c820b61e5905e2">make_int3()</a>  </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1int4.html">int4</a> </td><td>4D vector of integers </td><td><a class="el" href="structhelios_1_1int4.html#a1ac3b0b91901dc1d1497267bd3f3b4c3">x</a>, <a class="el" href="structhelios_1_1int4.html#ae979ffc27c702a6b67258d07ddcdf3b3">y</a>, <a class="el" href="structhelios_1_1int4.html#a5c5969a3b94d165c3a24a5235ea50a99">z</a>, <a class="el" href="structhelios_1_1int4.html#a997159b161576d521fdad7e2d5e3786f">w</a> </td><td>none </td><td><a class="el" href="helios__vector__types_8h.html#af5edd33a4cda51030ee6a7835c6965ce">make_int4()</a>  </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1_r_g_bcolor.html">RGBcolor</a> </td><td>red-green-blue color code </td><td><a class="el" href="structhelios_1_1_r_g_bcolor.html#a3e16659a90c69e6043c33c113b2fffe8">r</a>, <a class="el" href="structhelios_1_1_r_g_bcolor.html#ae002d220d8695538760eee2a6c4e9023">g</a>, <a class="el" href="structhelios_1_1_r_g_bcolor.html#a1b3ba3f5b77ef3082088eff853d4c335">b</a> </td><td><a class="el" href="structhelios_1_1_r_g_bcolor.html#a771797b0f691366993444b0867710ca8">scale()</a> </td><td><a class="el" href="group__vectors.html#gae5b981fa224fe6f30b850467ec655c0b">make_RGBcolor()</a>  </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1_r_g_b_acolor.html">RGBAcolor</a> </td><td>red-green-blue-alpha color code </td><td><a class="el" href="structhelios_1_1_r_g_b_acolor.html#a15af7f1c4d0e5e23a7ec2488fe0964df">r</a>, <a class="el" href="structhelios_1_1_r_g_b_acolor.html#ac018f8ed01b4d4128a68ebe42e1e6a00">g</a>, <a class="el" href="structhelios_1_1_r_g_b_acolor.html#aaa86bd3e17f03ffdc182c5c9b67587e3">b</a>, <a class="el" href="structhelios_1_1_r_g_b_acolor.html#a1941a63762f40fe1aabc5bb863a7aa1e">a</a> </td><td><a class="el" href="structhelios_1_1_r_g_b_acolor.html#a61e8dfbd88c4afa249997cfc4b02889d">scale()</a>, clamp() </td><td><a class="el" href="group__vectors.html#gacc4916e29a0757214b7c558c6e5f7cd3">make_RGBAcolor()</a>  </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1_time.html">Time</a> </td><td>Time of day </td><td><a class="el" href="structhelios_1_1_time.html#a627acedd68e0228600727b867db537dd">second</a>, <a class="el" href="structhelios_1_1_time.html#a744b90da076192b90a3ee4ce2ff3743a">minute</a>, <a class="el" href="structhelios_1_1_time.html#a6ec639cf61cf283c5e999d152d27839f">hour</a> </td><td>none </td><td><a class="el" href="group__vectors.html#ga7a29e9916b97d9f7533e87e7125e5b66">make_Time()</a>  </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1_date.html">Date</a> </td><td>Calendar date (MM,DD,YYYY) </td><td><a class="el" href="structhelios_1_1_date.html#a876b0513daf0bcf0ab305029be3377d8">day</a>, <a class="el" href="structhelios_1_1_date.html#a5d75f8c8616d778e470a59e0b3e890a3">month</a>, <a class="el" href="structhelios_1_1_date.html#aee4be32c2bd722143658b4771fe96253">year</a> </td><td><a class="el" href="structhelios_1_1_date.html#a9396638026040e4103b81388219b2a5b">JulianDay()</a> </td><td><a class="el" href="group__vectors.html#gad4c811a7a39319de43f58c93e14ecda6">make_Date()</a>  </td></tr>
</table>
<p>Vector types can be initialized by using their 'make_*()' function. For example, 'i2=make_int2(1,2);' creates an int2 with members 'i2.x -&gt; 1' and 'i2.y -&gt; 2'.</p>
<h2><a class="anchor" id="RGB"></a>
R-G-B(-A) color vectors</h2>
<p>There are several predefined RGB color vectors (see <a class="el" href="structhelios_1_1_r_g_bcolor.html">RGBcolor</a>) that can be used, which are tabulated below:</p>
<table class="doxtable">
<tr>
<th>Color </th><th>Code </th><th>Sample  </th></tr>
<tr>
<td>RGB::black </td><td>(0,0,0) </td><td><div style="width:50px;height:30px;background-color:rgb(0,0,0);"></div>  </td></tr>
<tr>
<td>RGB::white </td><td>(1,1,1) </td><td><div style="width:50px;height:30px;border:1px solid rgb(75,75,75);"></div>  </td></tr>
<tr>
<td>RGB::red </td><td>(1,0,0) </td><td><div style="width:50px;height:30px;background-color:rgb(255,0,0);"></div>  </td></tr>
<tr>
<td>RGB::blue </td><td>(0,0,1) </td><td><div style="width:50px;height:30px;background-color:rgb(0,0,255);"></div>  </td></tr>
<tr>
<td>RGB::green </td><td>(0,0.6,0) </td><td><div style="width:50px;height:30px;background-color:rgb(0,127,0);"></div>  </td></tr>
<tr>
<td>RGB::cyan </td><td>(0,1,1) </td><td><div style="width:50px;height:30px;background-color:rgb(0,255,255);"></div>  </td></tr>
<tr>
<td>RGB::magenta </td><td>(1,0,1) </td><td><div style="width:50px;height:30px;background-color:rgb(255,0,255);"></div>  </td></tr>
<tr>
<td>RGB::yellow </td><td>(1,1,0) </td><td><div style="width:50px;height:30px;background-color:rgb(255,255,0);"></div>  </td></tr>
<tr>
<td>RGB::orange </td><td>(1,0.5,0) </td><td><div style="width:50px;height:30px;background-color:rgb(255,127,0);"></div>  </td></tr>
<tr>
<td>RGB::violet </td><td>(0.5,0,0.5) </td><td><div style="width:50px;height:30px;background-color:rgb(127,0,127);"></div>  </td></tr>
<tr>
<td>RGB::lime </td><td>(0,1,0) </td><td><div style="width:50px;height:30px;background-color:rgb(0,255,0);"></div>  </td></tr>
<tr>
<td>RGB::silver </td><td>(0.75,0.75,0.75) </td><td><div style="width:50px;height:30px;background-color:rgb(191,191,191);"></div>  </td></tr>
<tr>
<td>RGB::gray </td><td>(0.5,0.5,0.5) </td><td><div style="width:50px;height:30px;background-color:rgb(127,127,127);"></div>  </td></tr>
<tr>
<td>RGB::navy </td><td>(0,0,0.5) </td><td><div style="width:50px;height:30px;background-color:rgb(0,0,127);"></div>  </td></tr>
<tr>
<td>RGB::brown </td><td>(0.55,0.27,0.075) </td><td><div style="width:50px;height:30px;background-color:rgb(140,69,19);"></div>  </td></tr>
<tr>
<td>RGB::khaki </td><td>(0.94,0.92,0.55) </td><td><div style="width:50px;height:30px;background-color:rgb(240,235,140);"></div>  </td></tr>
<tr>
<td>RGB::greenyellow </td><td>(0.678,1,0.184) </td><td><div style="width:50px;height:30px;background-color:rgb(173,255,47);"></div>  </td></tr>
<tr>
<td>RGB::forestgreen </td><td>(0.133,0.545,0.133) </td><td><div style="width:50px;height:30px;background-color:rgb(34,139,34);"></div>  </td></tr>
<tr>
<td>RGB::yellowgreen </td><td>(0.6,0.8,0.2) </td><td><div style="width:50px;height:30px;background-color:rgb(153,204,51);"></div>  </td></tr>
<tr>
<td>RGB::goldenrod </td><td>(0.855,0.647,0.126) </td><td><div style="width:50px;height:30px;background-color:rgb(218,165,32);"></div>  </td></tr>
</table>
<p>Note that the above colors can be directly passed to <a class="el" href="group__vectors.html#gacc4916e29a0757214b7c558c6e5f7cd3">make_RGBAcolor</a> to specify an alpha (transparency) value:</p>
<div style="padding:2px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> RGBAcolor red_trans = make_RGBAcolor( RGB::red, 0.5 );</code></pre> </div><h1><a class="anchor" id="Coord"></a>
Coordinate System</h1>
<p>Helios uses a right-handed Cartesian coordinate system. (x,y,z) coordinates are typically specified using the 'vec3' data structure (see <a class="el" href="_a_p_i.html#VecTypes">Vector Types</a>).</p>
<p>Rotations are typically specified using spherical angles (see <a class="el" href="_a_p_i.html#VecTypes">Vector Types</a>). A rotation of the elevation angle <img class="formulaInl" alt="$\theta$" src="form_3.png"/> rotates the object about its y-axis. A rotation of the azimuthal angle <img class="formulaInl" alt="$\varphi$" src="form_4.png"/> rotates the object clockwise about its z-axis.</p>
<p>When compass directions are used, +y corresponds to North, and +x corresponds East. The azimuthal angle <img class="formulaInl" alt="$\varphi$" src="form_4.png"/> is measured clockwise from North.</p>
<div class="image">
<img src="CoordinateSystem.jpg" alt="CoordinateSystem.jpg"/>
</div>
 <div class="image">
<img src="CompassCoord.jpeg" alt="CompassCoord.jpeg"/>
<div class="caption">
Coordinate system.</div></div>
<h1><a class="anchor" id="Geom"></a>
Geometry</h1>
<p>The Helios framework is centered around geometric objects called 'primitives'. Primitive elements build up the geometry of the domain, and typically store the data that couples models. For example, each primitive may have an associated surface temperature value that is updated or used by several different models.</p>
<h2><a class="anchor" id="PrimitiveTypes"></a>
Primitive Types</h2>
<p>All primitives inherit the class '<a class="el" href="classhelios_1_1_primitive.html">Primitive</a>', which give them common properties and functions. The available geometric primitive types are detailed below. Each primitive type has an enumeration that can be used in the code to reference each primitive type.</p>
<table class="doxtable">
<tr>
<th>Primitive </th><th>Description </th><th>Enumeration  </th></tr>
<tr>
<td><a class="el" href="classhelios_1_1_patch.html">Patch</a> </td><td>Rectangular polygon with coplanar vertices. A patch is specified by the (x,y,z) coordinate of its center and by the lengths of its sides in the x- and y-directions. The default orientation of a patch is horizontal (i.e., it's normal is in the +z direction). </td><td>PRIMITIVE_TYPE_PATCH  </td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_triangle.html">Triangle</a> </td><td>Triangular polygon specified by its three vertices. </td><td>PRIMITIVE_TYPE_TRIANGLE  </td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_voxel.html">Voxel</a> </td><td>Parallelpiped or rectangular prism. A voxel is specified by the (x,y,z) coordinate of its center and by the lenghts of its sides in the x-, y-, and z-directions. The default orientation of a voxel is axis-aligned. </td><td>PRIMITIVE_TYPE_VOXEL  </td></tr>
</table>
<h2><a class="anchor" id="AddingPrims"></a>
Adding Primitives</h2>
<p>Primitives are referenced by their 'universal uinique identifier' or UUID. When a function is called to add a primitive to the context, a UUID is returned that can be used later to reference the primitive. Objects can be formed simply by storing a group of UUIDs corresponding to the primitives that make up the object.</p>
<p>Each primitive type has a different function that is used to add it to the Context, which are detailed in the table below.</p>
<table class="doxtable">
<tr>
<th>Primitive </th><th>Adder function  </th></tr>
<tr>
<td><a class="el" href="classhelios_1_1_patch.html">Patch</a> </td><td><ul>
<li>
<a class="el" href="group__primitives.html#gafaae593d52d284c5aab98e29cee0cd76">addPatch( vec3 center, vec2 size )</a> </li>
<li>
<a class="el" href="group__primitives.html#ga148090c69c7b04bbfbae4eed2443a235">addPatch( vec3 center, vec2 size, SphericalCoord rotation )</a> </li>
<li>
<a class="el" href="classhelios_1_1_context.html#a7ead8162aab12a399925aa89a6f9007c">addPatch( vec3 center, vec2 size, SphericalCoord rotation, RGBcolor color )</a>  </li>
<li>
<a class="el" href="group__primitives.html#ga953a329d019e3c91948b139215c748af">addPatch( vec3 center, vec2 size, SphericalCoord rotation, const char* texture_file )</a> </li>
</ul>
</td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_triangle.html">Triangle</a> </td><td><ul>
<li>
<a class="el" href="group__primitives.html#ga2a78a464a4c7ef3375a0ced2f1005b77">addTriangle( vec3 vertex0, vec3 vertex1, vec3 vertex2 )</a> </li>
<li>
<a class="el" href="group__primitives.html#gafedf69d3c13704eac0b1cdbaedfc2f5c">addTriangle( vec3 vertex0, vec3 vertex1, vec3 vertex2, RGBcolor color )</a> </li>
</ul>
</td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_voxel.html">Voxel</a> </td><td><ul>
<li>
<a class="el" href="group__primitives.html#ga5c3476d33e4c6125276bcae114b49b10">addVoxel( vec3 center, vec3 size )</a> </li>
<li>
<a class="el" href="group__primitives.html#gab03110bd9b0a7d4bdfedfe1e7881b6b0">addVoxel( vec3 center, vec3 size, float rotation )</a> </li>
</ul>
</td></tr>
</table>
<h3><a class="anchor" id="AddingPatch"></a>
Adding Patches</h3>
<p>Patches are added by specifying the (x,y,z) coordinate of its center, the lengths of its sides in the x- and y-directions, and optionally its spherical rotation (see <a class="el" href="_a_p_i.html#Coord">Coordinate System</a>) and r-g-b color. The following is an example of using the 'addPatch' function to add a simple patch:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    Context context;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    vec3 center = make_vec3(0,0,1);
    vec2 size = make_vec2(1,1);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    uint UUID; //universal unique identifier
    UUID = context.addPatch( center, size );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre> </div><p>This will add the Patch shown below, with the default orientation of horizontal. (Note that the addition of the checkerboard ground and the '<a class="el" href="class_visualizer.html">Visualizer</a>' plugin is needed to replicate this image, which is not shown in the example code.)</p>
<div class="image">
<img src="Patch.png" alt="Patch.png"/>
<div class="caption">
Patch geometric primitive.</div></div>
<p> The patch can also be rotated by adding the optional SphericalCoord argument:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec3 center = make_vec3(0,0,1);
 vec2 size = make_vec2(1,1);
 SphericalCoord rotation = make_SphericalCoord(0.25*M_PI,0.5*M_PI);
 context.addPatch( center, size, rotation );</code></pre> </div><p>This will first rotate the patch by 0.25 <img class="formulaInl" alt="$\pi$" src="form_83.png"/> rad about the x-axis such that its normal is pointing toward the +y direction, THEN it will apply a clockwise azimuthal rotation of 0.5 <img class="formulaInl" alt="$\pi$" src="form_83.png"/> rad such that its normal is pointing in the +x direction (which will be its final orientation). Note that in order to have more control over rotations, it is recommended to use the Primitive::rotate() function (see "Primitive Transformations" section below).</p>
<h3><a class="anchor" id="AddingTriangle"></a>
Adding Triangles</h3>
<p>Triangles are added by specifying the (x,y,z) coordinates of the triangle's three vertices, and optionally its r-g-b color. The following is an example of using the 'addTriangle()' function to add a simple triangle:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    Context context;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    vec3 v0 = make_vec3(-0.5,-0.5,1);
    vec3 v1 = make_vec3(0.5,-0.5,1);
    vec3 v2 = make_vec3(0,0.5,1);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    uint UUID; //universal unique identifier
    UUID = context.addTriangle( v0, v1, v2, RGB::red );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre> </div><p>This will add the Triangle shown below. (Note that the addition of the checkerboard ground and the '<a class="el" href="class_visualizer.html">Visualizer</a>' plugin is needed to replicate this image, which is not shown in the example code.)</p>
<div class="image">
<img src="Triangle.png" alt="Triangle.png"/>
<div class="caption">
Triangle geometric primitive.</div></div>
<p> An important note for triangles is that the normal direction of the triangle follows the right-hand rule: use your right hand to connect each of the vertices in the order specified, and your thumb will point in the normal direction. This is illustrated in the figure below.</p>
<div class="image">
<img src="triangle_right-hand-rule.jpeg" alt="triangle_right-hand-rule.jpeg"/>
<div class="caption">
Right-hand rule to determine triangle normal direction based on the three vertices 0, 1, and 2.</div></div>
 <h3><a class="anchor" id="AddingVoxel"></a>
Adding Voxels</h3>
<p>Voxels are added by specifying the (x,y,z) coordinate of its center, the lengths of its sides in the x-, y-, and z-directions, and optionally its spherical rotation (see <a class="el" href="_a_p_i.html#Coord">Coordinate System</a>) and r-g-b color. The following is an example of using the 'addVoxel()' function to add a simple voxel:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    Context context;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    vec3 center = make_vec3(0,0,1);
    vec3 size = make_vec3(1,1,1);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    uint UUID; //universal unique identifier
    UUID = context.addVoxel( center, size, RGB::red );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre> </div><p>This will add the Voxel shown below, with the default orientation of horizontal. (Note that the addition of the checkerboard ground and the 'visualizer' plugin is needed to replicate this image, which is not shown in the example code.)</p>
<div class="image">
<img src="Voxel.png" alt="Voxel.png"/>
<div class="caption">
Voxel geometric primitive.</div></div>
<p> The voxel can also be rotated by adding the optional SphericalCoord argument:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec3 center = make_vec3(0,0,1);
 vec3 size = make_vec3(1,1,1);
 rotation = 0.25*M_PI;
 context.addVoxel( center, size, rotation, RGB::red );</code></pre> </div><h2><a class="anchor" id="PrimTransform"></a>
Primitive Transformations</h2>
<p>After primitives have been added to the Context, their position, size, and orientation can be further modified through transformations.</p>
<p>All primitives have member functions Primitive::scale(), Primitive::translate(), and Primitive::rotate() which modify the size, position, and orientation of the primitive, respectively. The Primitive::scale() function takes a vec3 that denotes a scaling factor to apply in each Cartesian direction (x,y,z). The Primitive::translate() function moves the primitive based on values provided by a vec3 that specifies the distance to translate in the x-, y-, and z-directions.</p>
<p>The Primitive::rotate() function rotates the primitive about an axis through and angle specified in radians. To rotate about one of the x-, y-, or z-axes, the function can be supplied a string of 'x', 'y', or 'z', respectively. The primitive can also be rotated about an arbitrary axis described by a unit vector argument.</p>
<p>It is important to note that the order that transformations are applied is important. Each transformation is applied based on the primitives current state. Rotating a primitive centered about the origin will cause the primitive to rotate about its own center. However, if a primitive is first translated then rotated, the primitive will be rotated about the origin, which does not necessarily coincide with the primitive's center if it has been translated.</p>
<h2><a class="anchor" id="PrimProps"></a>
Primitive Properties</h2>
<p>All primitives have a common set of data that can be accessed by the same set of functions. These functions are accessed through a pointer to the primitive:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> uint UUID; //universal unique identifier
 UUID = context.addVoxel( center, size, RGB::red );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> Primitive* prim = context.getPrimitivePointer(UUID);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> float area = prim-&gt;getArea();</code></pre> </div><p>The table below gives a list of all availalbe primitive functions.</p>
<table class="doxtable">
<tr>
<th>Property </th><th>Getter Function  </th></tr>
<tr>
<td>UUID </td><td><a class="el" href="classhelios_1_1_primitive.html#abb07768728fdeae636a3e22fb94d47a8">getUUID()</a>  </td></tr>
<tr>
<td>Primitive Type </td><td><a class="el" href="classhelios_1_1_primitive.html#a39e4b6e3903cd6e395e242eb28b172b9">getType()</a>  </td></tr>
<tr>
<td>Surface Area </td><td><a class="el" href="classhelios_1_1_primitive.html#a2e140af864e6dcb56d6ea5f85fef8f49">getArea()</a>  </td></tr>
<tr>
<td>Normal Vector </td><td><a class="el" href="classhelios_1_1_primitive.html#a0b57d12757d213978d5e0eec30c6eeb4">getNormal()</a>  </td></tr>
<tr>
<td>Affine Transformation Matrix </td><td><a class="el" href="classhelios_1_1_primitive.html#ac2f1ded5ace6e33830a5dc2bdf4e554c">getTransformationMatrix()</a>  </td></tr>
<tr>
<td>Vertex Coordinates (x,y,z) </td><td><a class="el" href="classhelios_1_1_primitive.html#a4ab9772c7b26919fdf3e31ff1d5be4a5">getVertices()</a>  </td></tr>
<tr>
<td>Diffuse R-G-B color code </td><td><a class="el" href="classhelios_1_1_primitive.html#a123006f09b743e84be76774c38dc823c">getColor()</a>  </td></tr>
<tr>
<td>Name of texture map file </td><td><a class="el" href="classhelios_1_1_primitive.html#a6a082e3b08e374cb38145cb7ea863e2b">getTextureFile()</a>  </td></tr>
</table>
<p>Some of these functions are not relevant to all primitive types. For example, Triangles cannot be texture mapped, and thus 'getTextureFile()' is not relevant. The available primitive functions and their relevance to each primitive type is given in the table below.</p>
<table class="doxtable">
<tr>
<th></th><th>Patch </th><th>Triangle </th><th>Voxel  </th></tr>
<tr>
<th>getUUID </th><td>X </td><td>X </td><td>X  </td></tr>
<tr>
<th>getType </th><td>X </td><td>X </td><td>X  </td></tr>
<tr>
<th>getArea </th><td>X </td><td>X </td><td>X  </td></tr>
<tr>
<th>getNormal </th><td>X </td><td>X </td><td>-  </td></tr>
<tr>
<th>getTransformationMatrix </th><td>X </td><td>X </td><td>X  </td></tr>
<tr>
<th>getVertices </th><td>X </td><td>X </td><td>X  </td></tr>
<tr>
<th>getColor </th><td>X </td><td>X </td><td>X  </td></tr>
<tr>
<th>getTextureFile </th><td>X </td><td>X </td><td>-  </td></tr>
</table>
<p>Some primitives have special functions specific to that type of primitive. For example, one may want to query the volume of a Voxel, or get the maskfile for an AlphaMask. These special functions are tabulated below. In order to use the special functions, you must get a pointer to the primitive type (e.g., Patch, Triangle, etc.) not the primitive. This is done using the 'get[*]Pointer' functions (e.g., <a class="el" href="group__primitives.html#ga0e3ac5f6948b1207d1fd2a9c3a1f6bb7">getPatchPointer()</a>). The example below illustrates how to get a pointer to a Patch, which is then used to query its size.</p>
<table class="doxtable">
<tr>
<th>Primitive Type </th><th>Pointer Getter Function </th><th>Special Function  </th></tr>
<tr>
<td>Patch </td><td><a class="el" href="group__primitives.html#ga0e3ac5f6948b1207d1fd2a9c3a1f6bb7">getPatchPointer()</a> </td><td><ul>
<li>
<a class="el" href="classhelios_1_1_patch.html#aa0c937c9a01cb1240b64b559926d6a20">getSize()</a> </li>
<li>
<a class="el" href="classhelios_1_1_patch.html#a49fb42f2fb1e9a5587467725eb9e8d0c">getCenter()</a> </li>
</ul>
</td></tr>
<tr>
<td>Triangle </td><td><a class="el" href="group__primitives.html#gab16737751d7bfcd72ad94af377acf311">getTrianglePointer()</a> </td><td><ul>
<li>
<a class="el" href="classhelios_1_1_triangle.html#adc18079107231d0e5840f289877f9ac1">getVertex( int number )</a> </li>
</ul>
</td></tr>
<tr>
<td>Voxel </td><td><a class="el" href="group__primitives.html#gaf8dbd92968a053bd8535e235d4e56800">getVoxelPointer()</a> </td><td><ul>
<li>
<a class="el" href="classhelios_1_1_voxel.html#ac4814476c2ff5245ac681b4feb6c53e6">getSize()</a> </li>
<li>
<a class="el" href="classhelios_1_1_voxel.html#ab90c498a428bacd2d5d9b96d55e055a4">getCenter()</a> </li>
<li>
<a class="el" href="classhelios_1_1_voxel.html#a7867d276d1d27011aa7cbe640030c522">getVolume()</a> </li>
</ul>
</td></tr>
</table>
<p><br />
</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>// Initialize the Context
    Context context;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>// Add 'Patch' primitive 
    vec3 center = make_vec3(0,0,1);
    vec2 size = make_vec2(1,1);
    uint UUID = context.addPatch( center, size, RGB::red );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>// Get pointer to Patch
    Patch* patch = context.getPatchPointer(UUID);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>// Get Patch size
    vec2 SIZE = patch-&gt;getSize();</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre> </div><h2><a class="anchor" id="Texture"></a>
Texture Mapping</h2>
<p>Images can be overlaid on patches and triangles through a process called <a href="https://en.wikipedia.org/wiki/Texture_mapping">texture mapping</a>. There are typically two reasons for doing this. One is simply for visualization purposes, as it easily allows for complex coloring of a surface by coloring a surface according to an image. The other is to create a more complex shape by removing a portion of the primitive surface according to the transparency channel of an image. Each of these cases are described in detail below.</p>
<h2><a class="anchor" id="TextureColor"></a>
Coloring Primitives by Texture Map</h2>
<p>Patches: To color a Patch based on an image, simply pass the path to a PNG or JPEG image to the appropriate argument of the addPatch() command. Note that the path should either be absolute, or relative to the directory where the executable will be run (typically the `build' directory).</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec3 center = make_vec3(0,0,1);
 vec2 size = make_vec2(2.5,1);
 SphericalCoord rotation = make_SphericalCoord(0,0);
 context.addPatch( center, size, rotation, "PSL_logo_white.png");</code></pre> </div><p><br />
 </p>
<div class="image">
<img src="Patch_textured.png" alt="Patch_textured.png"/>
<div class="caption">
Patch geometric primitive colored by texture map.</div></div>
<p> By default, the image is stretched to fill the entire surface of the patch. Alternatively, custom mapping coordinates can be supplied.</p>
<p>Patches:</p>
<div class="image">
<img src="AspenLeaf_uv_patch.png" alt="AspenLeaf_uv_patch.png"/>
<div class="caption">
.</div></div>
<p> Triangles:</p>
<div class="image">
<img src="AspenLeaf_uv_triangle.png" alt="AspenLeaf_uv_triangle.png"/>
<div class="caption">
.</div></div>
 <h2><a class="anchor" id="TextureMask"></a>
Masking Primitives by Image Transparency Channel</h2>
<p>If the image provided for texture mapping has a transparency channel, the portion of the primitive that is transparent will automatically be removed, and the rest of the non-transparent portion of the primitive will be colored according to the image. Note that only PNG images are supported, since JPEG images do not have transparency. An example is given below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>// Initialize the Context
    Context context;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>// Add 'Patch' primitive with transparency mask
    vec3 center = make_vec3(0,0,1);
    vec2 size = make_vec2(1,1);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    uint UUID = context.addPatch( center, size, make_SphericalCoord(0,0), "GrapeLeaf.png" );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre> </div><div class="image">
<img src="AlphaMask_leaf.png" alt="AlphaMask_leaf.png"/>
<div class="caption">
Rectangular patch masked by an image with a transparency channel.</div></div>
 <h2><a class="anchor" id="Compound"></a>
Compound Objects</h2>
<table class="doxtable">
<tr>
<th>Object </th><th>Description </th><th>Adder function(s) </th><th>Example  </th></tr>
<tr>
<td>Tile </td><td>Patch subdivided into uniform grid of sub-patches. </td><td><ul>
<li>
<a class="el" href="group__compoundobjects.html#ga304395049f552996da7db2cbe43ca2ab">addTile( const vec3 center, const vec2 size, const SphericalCoord rotation, const int2 subdiv )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#ga7c86f3cece7f0f3a1ad57e0485e586e9">addTile( const vec3 center, const vec2 size, const SphericalCoord rotation, const int2 subdiv, const RGBcolor color )</a>  </li>
</ul>
</td><td><div class="image">
<img src="Tile.png" alt="Tile.png"/>
</div>
  </td></tr>
<tr>
<td>Sphere </td><td>Spherical object tesselated with Triangle primitives. </td><td><ul>
<li>
<a class="el" href="group__compoundobjects.html#ga58166467cf1372dd4775e519ef904a9f">addSphere( uint Ndivs, vec3 center, float radius )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#ga1b09b894171a2f583a1f5579b857d8a0">addSphere( uint Ndivs, vec3 center, float radius, RGBcolor color )</a>  </li>
</ul>
</td><td><div class="image">
<img src="Sphere.png" alt="Sphere.png"/>
</div>
  </td></tr>
<tr>
<td>Tube </td><td>Cylindrical tube object tesselated with Triangle primitives. Follows a specified path and can change radius along its length. </td><td><ul>
<li>
<a class="el" href="group__compoundobjects.html#ga262a33adffa14d003f906cb0c231543d">addTube( uint Ndivs, vector&lt;vec3&gt; nodes, vector&lt;float&gt; radius )</a> </li>
<li>
<a class="el" href="group__compoundobjects.html#ga8a34f8fb40441ae4f984adfb8587ac05">addTube( uint Ndivs, vector&lt;vec3&gt; nodes, vector&lt;float&gt; radius, RGBcolor color )</a> </li>
</ul>
</td><td><div class="image">
<img src="Tube.png" alt="Tube.png"/>
</div>
  </td></tr>
<tr>
<td>Box </td><td>Rectangular prism object tesselated with Patch primitives.. </td><td><ul>
<li>
<a class="el" href="group__compoundobjects.html#ga2acbc90885fa5d0d36f5d355b368a5c4">addBox( vec3 center, vec3 size, int3 subdiv )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#ga421443667988dbe4717dd7ea36711607">addBox( vec3 center, vec3 size, int3 subdiv, RGBcolor color )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#gacfd57044c718d07dc86d71a7c19dd49a">addBox( vec3 center, vec3 size, int3 subdiv, RGBcolor color, bool reverse_normals )</a>  </li>
</ul>
</td><td><div class="image">
<img src="Box.png" alt="Box.png"/>
</div>
  </td></tr>
<tr>
<td>Disk </td><td>Ellipsoidal disk object tesselated with Triangle primitives.. </td><td><ul>
<li>
addDisk( uint Ndiv, helios::vec3 center, helios::vec2 size )  </li>
<li>
addDisk( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation )  </li>
<li>
addDisk( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation, helios::RGBcolor color )  </li>
<li>
addDisk( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation, helios::RGBAcolor color )  </li>
<li>
addDisk( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation, const char* texture_file )  </li>
</ul>
</td><td><div class="image">
<img src="Disk.png" alt="Disk.png"/>
</div>
  </td></tr>
</table>
<h1><a class="anchor" id="Data"></a>
Data Structures</h1>
<p>Data structures that are moved in and out of plugins are managed by the Context. There are two types of Context data structures that serve different purposes:</p>
<ul>
<li>
<b>Primitive Data</b> - is a piece of data associated with a given primitive. An example of this may be the reflectivity or temperature of a given primitive. Primitive data is flexible in that it can have different data types, variable lengths, and can be different for different primitives. For example, voxels could have a data value specifying the attenuation coefficient, but the attenuation coefficient would not be relevant for patches so they would not have this piece of data. A given primitive could have an array of 10 integers as its data. However, primitive data is limited to one-dimensional arrays, and mapping to multidimensional data is left to the user. </li>
<li>
<b>Global Data</b> - is similar to 'primitive data', except that global data is not necessarily associated with any particular primitive. An example of global data might be the solar radiative flux incident on the earth. </li>
</ul>
<p>Implementation of data structure usage is detailed for each type of structure below.</p>
<p>Only certain data types are supported for primitive and global data (below), which are referenced using their enumeration type.</p>
<table class="doxtable">
<tr>
<th>Data type </th><th>Enumeration (HeliosDataType)  </th></tr>
<tr>
<td> <font face="courier" color="green">int</font> </td><td>HELIOS_TYPE_INT  </td></tr>
<tr>
<td> <font face="courier" color="green">uint</font> </td><td>HELIOS_TYPE_UINT  </td></tr>
<tr>
<td> <font face="courier" color="green">float</font> </td><td>HELIOS_TYPE_FLOAT  </td></tr>
<tr>
<td> <font face="courier" color="green">double</font> </td><td>HELIOS_TYPE_DOUBLE  </td></tr>
<tr>
<td> <font face="courier" color="green">vec2</font> </td><td>HELIOS_TYPE_VEC2  </td></tr>
<tr>
<td> <font face="courier" color="green">vec3</font> </td><td>HELIOS_TYPE_VEC3  </td></tr>
<tr>
<td> <font face="courier" color="green">vec4</font> </td><td>HELIOS_TYPE_VEC4  </td></tr>
<tr>
<td> <font face="courier" color="green">int2</font> </td><td>HELIOS_TYPE_INT2  </td></tr>
<tr>
<td> <font face="courier" color="green">int3</font> </td><td>HELIOS_TYPE_INT3  </td></tr>
<tr>
<td> <font face="courier" color="green">int4</font> </td><td>HELIOS_TYPE_INT4  </td></tr>
<tr>
<td> <font face="courier" color="green">std::string</font> </td><td>HELIOS_TYPE_STRING  </td></tr>
</table>
<h2><a class="anchor" id="PrimData"></a>
Primitive Data</h2>
<h3><a class="anchor" id="SetPrimData"></a>
Setting Primitive Data Values</h3>
<p>Primitive data values can be scalar or a one-dimensional array of values.</p>
<p>Primitive data is set for a given primitive via the Context using the <a class="el" href="classhelios_1_1_context.html#af5cd7c605339016dd06e2cae52deb32a">setPrimitiveData()</a> function. Example use of this function for scalar data is given below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    Context context;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    uint UUID = context.addPatch( center, size, RGB::red );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    float eps = 0.9;
    context.setPrimitiveData(UUID,"emissivity",eps);
 }</code></pre> </div><p>Alternatively, primitive data can be set from a pointer to the primitive using <a class="el" href="classhelios_1_1_primitive.html#a9cf890cc9751acf7e50a97e311b9d786">setPrimitiveData()</a>:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> Primitive* prim = context-&gt;getPrimitivePointer(UUID);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> float eps = 0.9;
 prim.setPrimitiveData("emissivity",eps);</code></pre> </div><p>Reference <a class="el" href="group__primitives.html#ga51cdc1a049bd066d8037bf6ddf600388">getPrimitivePointer()</a> for further information on how to get a pointer to primitives.</p>
<p>There are multiple ways of setting vector primitive data. One method uses STL vectors to pass the data to the <a class="el" href="classhelios_1_1_context.html#af5cd7c605339016dd06e2cae52deb32a">setPrimitiveData()</a>, and another is accomplished using a pointer to a standard C vector. Both of these equivalent methods are illustrated below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    Context context;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    vec3 center(0,0,0);
    vec2 size(1,1);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    uint UUID = context.addPatch( center, size );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    std::vector&lt;float&gt; A;
    A.push_back(2.3);
    A.push_back(9.2);
    context.setPrimitiveData(UUID,"somedataA",HELIOS_TYPE_FLOAT,A.size(),&amp;A[0]);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    float B[2];
    B[0] = 2.3;
    B[1] = 9.2;
    context.setPrimitiveData(UUID,"somedataB",HELIOS_TYPE_FLOAT,2,&amp;B[0]);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre> </div><h3><a class="anchor" id="GetPrimData"></a>
Getting Primitive Data Values</h3>
<p>If primitive data is a scalar value, it can be retrieved for a given primitive via the Context using the <a class="el" href="classhelios_1_1_context.html#a9d3bec19ecfed99f1fee4c25ac7f37a4">getPrimitiveData</a> function:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    Context context;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    vec3 center(0,0,0);
    vec2 size(1,1);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    uint UUID = context.addPatch( center, size );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    float eps = 0.9;
    context.setPrimitiveData(UUID,"emissivity",eps);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    float emissivity;
    context.getPrimitiveData(UUID,"emissivity",emissivity);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre> </div><p>In the above example, the value of 'emissivity' is 0.9.</p>
<p>For a vector of primitive data, use the getPrimitiveData_v function. Note that the 'getPrimitiveData_v' function can always be used regardless of whether the data is scalar or vector valued. If the data is scalar and 'getPrimitiveData_v' is used, the function will simply return a vector structure of length 1.</p>
<h3><a class="anchor" id="PrimDataHelpers"></a>
Primitive Data Query Functions</h3>
<p>It is often necessary to query information about primitive data. The following table lists functions used to query primitive data information. Note that the query functions are called through a pointer to the primitive, not directly from the Context (see example below).</p>
<table class="doxtable">
<tr>
<th>Function </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="classhelios_1_1_primitive.html#aa2241f7d999a12a9b47949116a3ff886">doesPrimitiveDataExist( const char* label )</a> </td><td>Check whether primitive data named 'label' exists for the primitive.  </td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_primitive.html#aa7a7907e183212cd1d1a4cfd631bb310">getPrimitiveDataType( const char* label )</a> </td><td>Get the helios::HeliosDataType for the primitive.  </td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_primitive.html#af5eabf3325bfd0e097b6326ed69cc781">getPrimitiveDataSize( const char* label )</a> </td><td>Get the length/size of the primitive data named 'label'.  </td></tr>
</table>
<p><br />
 </p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    Context context;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    vec3 center(0,0,0);
    vec2 size(1,1);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    uint UUID = context.addPatch( center, size );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    float eps = 0.9;
    context.setPrimitiveData(UUID, "emissivity", eps);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    Primitive* prim context.getPrimitive(UUID);
    if( prim-&gt;doesPrimitiveDataExist("emissivity") ){
       HeliosDataType type = prim-&gt;getPrimitiveDataType("emissivity");
       uint L = prim-&gt;getPrimitiveDataSize("emissivity");
    }</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre> </div><h2><a class="anchor" id="GlobalData"></a>
Global Data</h2>
<p>Global data is similar to primitive data, except that it does not correspond to any particular primitive, rather it is a single instance of a certain data structure. The functions used to create global data within the Context are essentially the same as those used to create primitive data, except they do not take a primitive UUID as an argument (because they do not correspond to primitives).</p>
<h2><a class="anchor" id="DataTimeseries"></a>
Data Timeseries</h2>
<p>Timeseries - or data points corresponding to discrete points in time - can be managed by the Context. This typically corresponds to data that is measured by a sensor. Timeseries data points are added to the Context by giving the value of the data point, along with <a class="el" href="structhelios_1_1_date.html">Date</a> and <a class="el" href="structhelios_1_1_time.html">Time</a> vectors. An example is given below to manualy add 15-min timeseries data to the Context.</p>
<p>Data in the timeseries can be accessed either via the queryTimeseriesData() function by giving the index of the data point, or by giving a date and time. To loop through all data in the timeseries, we can query the length of the timeseries and make a for-loop.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       <code></code>// Initialize the Context
       Context context;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       <code></code>// Add data to timeseries
       Date date;
       Time time;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       date = make_Date( 2, 1, 2000 ); <code></code>// 2 Jan. 2000</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       time = make_Time( 13, 00, 00 ); <code></code>// 13:00:00
       context.addTimeseriesData( "temperature", 301.23, date, time ); <code></code>// index #0</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       time = make_Time( 13, 15, 00 ); <code></code>// 13:15:00
       context.addTimeseriesData( "temperature", 301.92, date, time ); <code></code>// index #1</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       time = make_Time( 13, 30, 00 ); <code></code>// 13:30:00
       context.addTimeseriesData( "temperature", 302.56, date, time ); <code></code>// index #2</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       time = make_Time( 13, 45, 00 ); <code></code>// 13:45:00
       context.addTimeseriesData( "temperature", 303.05, date, time ); <code></code>// index #3</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       float T;
       T = context.queryTimeseriesData( "temperature", 1 ); <code></code>// Here, T = 301.92</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       time = make_Time( 13, 15, 00 );
       T = context.queryTimeseriesData( "temperature", date, time ); <code></code>// Also here, T = 301.92</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       for( uint i=0; i&lt;context.getTimeseriesLength("temperature"); i++ ){
        T = context.queryTimeseriesData( "temperature", i );
            time = context.getTimeseriesTime( "temperature", i );
        printf("Temperature at time %02d:%02d:%02d is %f\n", time.hour, time.minute, time.second );                          
    }</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre> </div><p>Typically, data is not entered manually, but rather through an XML file (see Reading XML Files for information).</p>
<p>It is often necessary to get the number of data points in a given timeseries, which can be accomplished with the command:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> uint N = context.getTimeseriesLength( "temperature" );</code></pre> </div> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
