<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>.: Using the Helios API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Helios_logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">.
   &#160;<span id="projectnumber">v1.2.20</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Using the Helios API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#BuildCompile">Building and Compiling Your Own Projects</a><ul><li class="level2"><a href="#DirStruct">Basic Directory Structure</a></li>
<li class="level2"><a href="#BuildDir">Build Directory</a></li>
<li class="level2"><a href="#Source">Main and auxillary .cpp files</a></li>
<li class="level2"><a href="#CMake">CMakeLists.txt File</a></li>
<li class="level2"><a href="#DirScript">New Project Script</a></li>
</ul>
</li>
<li class="level1"><a href="#ContextSect">Context</a></li>
<li class="level1"><a href="#VecTypes">Vector Types</a><ul><li class="level2"><a href="#RGB">R-G-B(-A) color vectors</a></li>
</ul>
</li>
<li class="level1"><a href="#Coord">Coordinate System</a></li>
<li class="level1"><a href="#Geom">Geometry</a><ul><li class="level2"><a href="#PrimitiveTypes">Primitive Types</a></li>
<li class="level2"><a href="#AddingPrims">Adding Primitives</a><ul><li class="level3"><a href="#AddingPatch">Adding Patches</a></li>
<li class="level3"><a href="#AddingTriangle">Adding Triangles</a></li>
<li class="level3"><a href="#AddingVoxel">Adding Voxels</a></li>
</ul>
</li>
<li class="level2"><a href="#PrimTransform">Primitive Transformations</a></li>
<li class="level2"><a href="#PrimProps">Primitive Properties</a></li>
<li class="level2"><a href="#Transforms">Primitive Transformations</a></li>
<li class="level2"><a href="#Texture">Texture Mapping</a></li>
<li class="level2"><a href="#TextureColor">Coloring Primitives by Texture Map</a></li>
<li class="level2"><a href="#TextureMask">Masking Primitives by Image Transparency Channel</a></li>
<li class="level2"><a href="#Compound">Compound Geometry</a></li>
<li class="level2"><a href="#Objects">Objects</a></li>
</ul>
</li>
<li class="level1"><a href="#Data">Data Structures</a><ul><li class="level2"><a href="#PrimData">Primitive Data</a><ul><li class="level3"><a href="#SetPrimData">Setting Primitive Data Values</a></li>
<li class="level3"><a href="#GetPrimData">Getting Primitive Data Values</a></li>
<li class="level3"><a href="#PrimDataHelpers">Primitive Data Query Functions</a></li>
</ul>
</li>
<li class="level2"><a href="#GlobalData">Global Data</a></li>
<li class="level2"><a href="#DataTimeseries">Data Timeseries</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="BuildCompile"></a>
Building and Compiling Your Own Projects</h1>
<h2><a class="anchor" id="DirStruct"></a>
Basic Directory Structure</h2>
<p>Projects that use the Helios API can be located in any directory, and simply need to reference the location of the source code and plug-ins. Typically the project directory contains the following files and directories (see 'samples' directory for examples):</p>
<ul>
<li>
'build' directory. </li>
<li>
.cpp file containing a main() routine, and other auxillary .cpp files. </li>
<li>
CMakeLists.txt file, which is used to generate a makefile (see next section). </li>
<li>
.h header files (optional). </li>
</ul>
<p>A prototypical directory structure for a project folder is given below:</p>
<ul>
<li>
build (directory)  <ul>
<li>
executable  </li>
</ul>
</li>
<li>
CMakeLists.txt  </li>
<li>
main.cpp  </li>
</ul>
<h2><a class="anchor" id="BuildDir"></a>
Build Directory</h2>
<p>It is generally convenient to have a separate directory in which the project is built. This makes it easy to start fresh with a new build, or create multiple builds on different systems. Usually, the build directory is a subdirectory within the project directory (see 'samples' directory for examples).</p>
<h2><a class="anchor" id="Source"></a>
Main and auxillary .cpp files</h2>
<p>Projects using the Helios API must have a file containing a main() program, and can have any number of complimentary routines and files. Generally, the file containing the main program will include the <a class="el" href="_context_8h.html">Context.h</a> header file, and declare the Context class (see Sect. <a class="el" href="_a_p_i.html#ContextSect">Context</a> below).</p>
<h2><a class="anchor" id="CMake"></a>
CMakeLists.txt File</h2>
<p>Projects that use the Helios API are typically built using a CMakeLists.txt file. A prototypical CMakeLists.txt file used for building Helios samples and projects is given in the code sample below. Inputs for the specific case are entered in the top block of code by setting variables (see the CMake 'set' command reference). The user sets the location of the Helios base directory, the name of the executable file, any source or header files, and a list of plug-ins to use (the example below uses the 'visualizer' plug-in).</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> # Helios standard CMakeLists.txt file version 1.4
 #-------- USER INPUTS ---------#

 #provide the path to Helios base directory, either as an absolut path or a path relative to the location of this file
 set( BASE_DIRECTORY "../.." )

 #define the name of the executable to be created
 set( EXECUTABLE_NAME "executable" )

 #provide name of source file(s) (separate multiple file names with semicolon)
 set( SOURCE_FILES "main.cpp" )

 #specify which plug-ins to use (separate plug-in names with semicolon)
 set( PLUGINS "visualizer" )

 #-------- MAIN CODE (Don't Modify) ---------#

 cmake_minimum_required(VERSION 2.4)
 project(helios)
 if ( WIN32 )
     SET(CMAKE_C_COMPILER_ID "MSVC")
     SET(CMAKE_CXX_COMPILER_ID "MSVC")
     SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /std:c++latest")
 else()
     SET(CMAKE_C_COMPILER_ID "GNU")
     SET(CMAKE_CXX_COMPILER_ID "GNU")
     SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
     if( CMAKE_BUILD_TYPE STREQUAL Debug )
         SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g" )
         SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")
     endif()
 endif()
 if(NOT DEFINED CMAKE_SUPPRESS_DEVELOPER_WARNINGS)
     set(CMAKE_SUPPRESS_DEVELOPER_WARNINGS 1 CACHE INTERNAL "No dev warnings")
 endif()
 set( LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib )
 add_executable( ${EXECUTABLE_NAME} ${SOURCE_FILES} )
 add_subdirectory( ${BASE_DIRECTORY}/core "lib" )
 target_link_libraries( ${EXECUTABLE_NAME} helios)
 LIST(LENGTH PLUGINS PLUGIN_COUNT)
 message("-- Loading ${PLUGIN_COUNT} plug-ins")
 foreach(PLUGIN ${PLUGINS})
      message("-- loading plug-in ${PLUGIN}")
      if( ${PLUGIN} STREQUAL ${EXECUTABLE_NAME} )
       message( FATAL_ERROR "The executable name cannot be the same as a plugin name. Please rename your executable." )
     endif()
     add_subdirectory( ${BASE_DIRECTORY}/plugins/${PLUGIN} "plugins/${PLUGIN}" )
     target_link_libraries( ${EXECUTABLE_NAME} ${PLUGIN} )
 endforeach(PLUGIN)
 include_directories( "${PLUGIN_INCLUDE_PATHS};${CMAKE_CURRENT_SOURCE_DIRECTORY}" )
 </code></pre></div><p>To run the CMakeLists.txt file, which creates a makefile, simply run the command 'cmake', followed by the path to the CMakeLists.txt file. If, as in the examples above, you are currently in the build directory and your CMakeLists.txt file is located one directory up, the CMake build is accomplished through:</p>
<div style="padding:12px;background-color:#D0D0D0 ;line-height:1.4;"> <code> $ cmake .. </code> </div><p>The code can then be compiled by issuing the 'make' command from the build directory, which will produce an executable in the build directory.</p>
<h2><a class="anchor" id="DirScript"></a>
New Project Script</h2>
<p>There is a script in the main Helios directory that can quickly set up a new project called "create_project.sh". First, create a new directory where the project will exist, for example:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>$ mkdir projects/myProject</code></pre></div><p>To set up the new project, run the create_project.sh script, with the input argument of the project directory:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>$ ./create_project.sh projects/myProjects</code></pre></div><p>This will create the CMakeLists.txt file, a main.cpp file template, and an empty build directory.</p>
<p>You can also specify plug-ins as command-line arguments to the create_project.sh script, in which case the script will create a CMakeLists.txt and main.cpp file that are set up to load those plug-ins:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>$ ./create_project.sh projects/myProjects radiation visualizer</code></pre></div><h1><a class="anchor" id="ContextSect"></a>
Context</h1>
<p>The Context is a C++ class that manages data and functions associated with the Helios framework. The functions of the Context are:</p>
<ol>
<li>
Add and manage geometric objects </li>
<li>
Manage data associated with geometric objects and models in general </li>
<li>
Manage inputs and outpus </li>
</ol>
<p>In simplest terms, the Context stores information associated with geometric objects (primitives) and their corresponding data.</p>
<p>In order to use the Context, the following header must be included:</p>
<div style="padding:2px;background-color:#D0D0D0; line-height: 1.2"> <pre><code> #include "Context.h" </code></pre> </div><p>The context is typically created within the main function:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height: 1.2;"> <pre><code> #include "Context.h" 

 void main(){
    Context context;
 }
</code></pre> </div><p>The Context is usually passed to plugins (see <a class="el" href="_plugins.html">Writing Plugins</a>), which gives them access to geometry and data.</p>
<h1><a class="anchor" id="VecTypes"></a>
Vector Types</h1>
<p>There are several vector types commonly used by the Context and other plugins (see <a class="el" href="_plugins.html">Writing Plugins</a>). These are C++ structures with at least two member variables. Helios vector types are defined by including the header file:</p>
<div style="padding:2px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "helios_vector_types.h" </code></pre> </div><p>Note that this header is included within the '<a class="el" href="_context_8h.html">Context.h</a>' header, so it is not necessary to include both.</p>
<p>Available vector types are detailed below.</p>
<table class="doxtable">
<tr>
<th>Type</th><th>Description</th><th>Data Fields</th><th>Member Functions</th><th>Creation Function </th></tr>
<tr>
<td><a class="el" href="structhelios_1_1vec2.html">vec2</a></td><td>2D vector of floats</td><td><a class="el" href="structhelios_1_1vec2.html#a8dda241c2560b203a3b0a479d1c9e12e">x</a>, <a class="el" href="structhelios_1_1vec2.html#ab4afff51f764cbf9bab0949ae067977e">y</a></td><td><a class="el" href="structhelios_1_1vec2.html#ad1f15c84950ca9973a3017af28f88b07">normalize()</a>, <a class="el" href="structhelios_1_1vec2.html#a1931ec5c78112202c14634634f429073">magnitude()</a></td><td><a class="el" href="group__vectors.html#ga34e381a53377fbe8682d89d8a9c24cc5">make_vec2()</a> </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1vec3.html">vec3</a></td><td>3D vector of floats</td><td><a class="el" href="structhelios_1_1vec3.html#a80003da235393c031b8561e678a184a1">x</a>, <a class="el" href="structhelios_1_1vec3.html#ac0be54042f7a639c99ea4dce377f9a65">y</a>, <a class="el" href="structhelios_1_1vec3.html#a870c14ca45729f58e8628a050ce38b6f">z</a></td><td><a class="el" href="structhelios_1_1vec3.html#a8a845d8cc299fc8ebac57b994859e055">normalize()</a>, <a class="el" href="structhelios_1_1vec3.html#adb96b24e6544d106a19e029c2594fee4">magnitude()</a></td><td><a class="el" href="helios__vector__types_8h.html#a35b1ff50d62c80cf63426e25ee814ca9">make_vec3()</a> </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1vec4.html">vec4</a></td><td>4D vector of floats</td><td><a class="el" href="structhelios_1_1vec4.html#a96036e1d3ac15f03190a7bbf74ce0d73">x</a>, <a class="el" href="structhelios_1_1vec4.html#a3dd547e787593c51f07a6ea131bcab8d">y</a>, <a class="el" href="structhelios_1_1vec4.html#a660ee0cf07d74bac3c989ce39e035d3b">z</a>, <a class="el" href="structhelios_1_1vec4.html#a5d4e8add341c4076176aac3574fe0937">w</a></td><td>none</td><td><a class="el" href="helios__vector__types_8h.html#ab90da9b5ba29d966547fcfe82de87ea5">make_vec4()</a> </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1int2.html">int2</a></td><td>2D vector of integers</td><td><a class="el" href="structhelios_1_1int2.html#ae14968ab74816df03efc977bb5d7b9c7">x</a>, <a class="el" href="structhelios_1_1int2.html#a369861259a6061aa4287f954238e1e21">y</a></td><td>none</td><td><a class="el" href="helios__vector__types_8h.html#a05ad3ecab7f008a6b1ee04b35f227115">make_int2()</a> </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1int3.html">int3</a></td><td>3D vector of integers</td><td><a class="el" href="structhelios_1_1int3.html#a1ce8c8391637ea6e33bb30b1d0adfc50">x</a>, <a class="el" href="structhelios_1_1int3.html#aeba3aa4380ec4d9c216f98be95083d5c">y</a>, <a class="el" href="structhelios_1_1int3.html#adb4b47bc05bdb62677200e025e4bf641">z</a></td><td>none</td><td><a class="el" href="helios__vector__types_8h.html#a88347513c8d7e764d5c820b61e5905e2">make_int3()</a> </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1int4.html">int4</a></td><td>4D vector of integers</td><td><a class="el" href="structhelios_1_1int4.html#a1ac3b0b91901dc1d1497267bd3f3b4c3">x</a>, <a class="el" href="structhelios_1_1int4.html#ae979ffc27c702a6b67258d07ddcdf3b3">y</a>, <a class="el" href="structhelios_1_1int4.html#a5c5969a3b94d165c3a24a5235ea50a99">z</a>, <a class="el" href="structhelios_1_1int4.html#a997159b161576d521fdad7e2d5e3786f">w</a></td><td>none</td><td><a class="el" href="helios__vector__types_8h.html#af5edd33a4cda51030ee6a7835c6965ce">make_int4()</a> </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1_r_g_bcolor.html">RGBcolor</a></td><td>red-green-blue color code</td><td><a class="el" href="structhelios_1_1_r_g_bcolor.html#a3e16659a90c69e6043c33c113b2fffe8">r</a>, <a class="el" href="structhelios_1_1_r_g_bcolor.html#ae002d220d8695538760eee2a6c4e9023">g</a>, <a class="el" href="structhelios_1_1_r_g_bcolor.html#a1b3ba3f5b77ef3082088eff853d4c335">b</a></td><td><a class="el" href="structhelios_1_1_r_g_bcolor.html#a771797b0f691366993444b0867710ca8">scale()</a></td><td><a class="el" href="group__vectors.html#gae5b981fa224fe6f30b850467ec655c0b">make_RGBcolor()</a> </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1_r_g_b_acolor.html">RGBAcolor</a></td><td>red-green-blue-alpha color code</td><td><a class="el" href="structhelios_1_1_r_g_b_acolor.html#a15af7f1c4d0e5e23a7ec2488fe0964df">r</a>, <a class="el" href="structhelios_1_1_r_g_b_acolor.html#ac018f8ed01b4d4128a68ebe42e1e6a00">g</a>, <a class="el" href="structhelios_1_1_r_g_b_acolor.html#aaa86bd3e17f03ffdc182c5c9b67587e3">b</a>, <a class="el" href="structhelios_1_1_r_g_b_acolor.html#a1941a63762f40fe1aabc5bb863a7aa1e">a</a></td><td><a class="el" href="structhelios_1_1_r_g_b_acolor.html#a61e8dfbd88c4afa249997cfc4b02889d">scale()</a>, clamp()</td><td><a class="el" href="group__vectors.html#gacc4916e29a0757214b7c558c6e5f7cd3">make_RGBAcolor()</a> </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1_time.html">Time</a></td><td>Time of day</td><td><a class="el" href="structhelios_1_1_time.html#a627acedd68e0228600727b867db537dd">second</a>, <a class="el" href="structhelios_1_1_time.html#a744b90da076192b90a3ee4ce2ff3743a">minute</a>, <a class="el" href="structhelios_1_1_time.html#a6ec639cf61cf283c5e999d152d27839f">hour</a></td><td>none</td><td><a class="el" href="group__vectors.html#ga7a29e9916b97d9f7533e87e7125e5b66">make_Time()</a> </td></tr>
<tr>
<td><a class="el" href="structhelios_1_1_date.html">Date</a></td><td>Calendar date (MM,DD,YYYY)</td><td><a class="el" href="structhelios_1_1_date.html#a876b0513daf0bcf0ab305029be3377d8">day</a>, <a class="el" href="structhelios_1_1_date.html#a5d75f8c8616d778e470a59e0b3e890a3">month</a>, <a class="el" href="structhelios_1_1_date.html#aee4be32c2bd722143658b4771fe96253">year</a></td><td><a class="el" href="structhelios_1_1_date.html#abf3a401379adb23851174683a9191efc">JulianDay()</a></td><td><a class="el" href="group__vectors.html#gad4c811a7a39319de43f58c93e14ecda6">make_Date()</a> </td></tr>
</table>
<p>Vector types can be initialized by using their 'make_*()' function. For example, 'i2=make_int2(1,2);' creates an int2 with members 'i2.x -&gt; 1' and 'i2.y -&gt; 2'.</p>
<h2><a class="anchor" id="RGB"></a>
R-G-B(-A) color vectors</h2>
<p>There are several predefined RGB color vectors (see <a class="el" href="structhelios_1_1_r_g_bcolor.html">RGBcolor</a>) that can be used, which are tabulated below:</p>
<table class="doxtable">
<tr>
<th>Color</th><th>Code</th><th>Sample </th></tr>
<tr>
<td>RGB::black</td><td>(0,0,0)</td><td><div style="width:50px;height:30px;background-color:rgb(0,0,0);"></div> </td></tr>
<tr>
<td>RGB::white</td><td>(1,1,1)</td><td><div style="width:50px;height:30px;border:1px solid rgb(75,75,75);"></div> </td></tr>
<tr>
<td>RGB::red</td><td>(1,0,0)</td><td><div style="width:50px;height:30px;background-color:rgb(255,0,0);"></div> </td></tr>
<tr>
<td>RGB::blue</td><td>(0,0,1)</td><td><div style="width:50px;height:30px;background-color:rgb(0,0,255);"></div> </td></tr>
<tr>
<td>RGB::green</td><td>(0,0.6,0)</td><td><div style="width:50px;height:30px;background-color:rgb(0,127,0);"></div> </td></tr>
<tr>
<td>RGB::cyan</td><td>(0,1,1)</td><td><div style="width:50px;height:30px;background-color:rgb(0,255,255);"></div> </td></tr>
<tr>
<td>RGB::magenta</td><td>(1,0,1)</td><td><div style="width:50px;height:30px;background-color:rgb(255,0,255);"></div> </td></tr>
<tr>
<td>RGB::yellow</td><td>(1,1,0)</td><td><div style="width:50px;height:30px;background-color:rgb(255,255,0);"></div> </td></tr>
<tr>
<td>RGB::orange</td><td>(1,0.5,0)</td><td><div style="width:50px;height:30px;background-color:rgb(255,127,0);"></div> </td></tr>
<tr>
<td>RGB::violet</td><td>(0.5,0,0.5)</td><td><div style="width:50px;height:30px;background-color:rgb(127,0,127);"></div> </td></tr>
<tr>
<td>RGB::lime</td><td>(0,1,0)</td><td><div style="width:50px;height:30px;background-color:rgb(0,255,0);"></div> </td></tr>
<tr>
<td>RGB::silver</td><td>(0.75,0.75,0.75)</td><td><div style="width:50px;height:30px;background-color:rgb(191,191,191);"></div> </td></tr>
<tr>
<td>RGB::gray</td><td>(0.5,0.5,0.5)</td><td><div style="width:50px;height:30px;background-color:rgb(127,127,127);"></div> </td></tr>
<tr>
<td>RGB::navy</td><td>(0,0,0.5)</td><td><div style="width:50px;height:30px;background-color:rgb(0,0,127);"></div> </td></tr>
<tr>
<td>RGB::brown</td><td>(0.55,0.27,0.075)</td><td><div style="width:50px;height:30px;background-color:rgb(140,69,19);"></div> </td></tr>
<tr>
<td>RGB::khaki</td><td>(0.94,0.92,0.55)</td><td><div style="width:50px;height:30px;background-color:rgb(240,235,140);"></div> </td></tr>
<tr>
<td>RGB::greenyellow</td><td>(0.678,1,0.184)</td><td><div style="width:50px;height:30px;background-color:rgb(173,255,47);"></div> </td></tr>
<tr>
<td>RGB::forestgreen</td><td>(0.133,0.545,0.133)</td><td><div style="width:50px;height:30px;background-color:rgb(34,139,34);"></div> </td></tr>
<tr>
<td>RGB::yellowgreen</td><td>(0.6,0.8,0.2)</td><td><div style="width:50px;height:30px;background-color:rgb(153,204,51);"></div> </td></tr>
<tr>
<td>RGB::goldenrod</td><td>(0.855,0.647,0.126)</td><td><div style="width:50px;height:30px;background-color:rgb(218,165,32);"></div> </td></tr>
</table>
<p>Note that the above colors can be directly passed to <a class="el" href="group__vectors.html#gacc4916e29a0757214b7c558c6e5f7cd3">make_RGBAcolor</a> to specify an alpha (transparency) value:</p>
<div style="padding:2px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> RGBAcolor red_trans = make_RGBAcolor( RGB::red, 0.5 );</code></pre> </div><h1><a class="anchor" id="Coord"></a>
Coordinate System</h1>
<p>Helios uses a right-handed Cartesian coordinate system. (x,y,z) coordinates are typically specified using the 'vec3' data structure (see <a class="el" href="_a_p_i.html#VecTypes">Vector Types</a>). <br  />
</p>
<p>Rotations are typically specified using spherical angles (see <a class="el" href="_a_p_i.html#VecTypes">Vector Types</a>). A rotation of the elevation angle <img class="formulaInl" alt="$\theta$" src="form_3.png" width="8" height="12"/> rotates the object about its y-axis. A rotation of the azimuthal angle <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/> rotates the object clockwise about its z-axis.</p>
<p>When compass directions are used, +y corresponds to North, and +x corresponds East. The azimuthal angle <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/> is measured clockwise from North.</p>
<div class="image">
<img src="CoordinateSystem.jpg" alt=""/>
</div>
 <div class="image">
<img src="CompassCoord.jpeg" alt=""/>
<div class="caption">
Coordinate system.</div></div>
<h1><a class="anchor" id="Geom"></a>
Geometry</h1>
<p>The Helios framework is centered around geometric objects called 'primitives'. Primitive elements build up the geometry of the domain, and typically store the data that couples models. For example, each primitive may have an associated surface temperature value that is updated or used by several different models.</p>
<h2><a class="anchor" id="PrimitiveTypes"></a>
Primitive Types</h2>
<p>All primitives inherit the class '<a class="el" href="classhelios_1_1_primitive.html">Primitive</a>', which give them common properties and functions. The available geometric primitive types are detailed below. Each primitive type has an enumeration that can be used in the code to reference each primitive type.</p>
<table class="doxtable">
<tr>
<th>Primitive</th><th>Description</th><th>Enumeration </th></tr>
<tr>
<td><a class="el" href="classhelios_1_1_patch.html">Patch</a></td><td>Rectangular polygon with coplanar vertices. A patch is specified by the (x,y,z) coordinate of its center and by the lengths of its sides in the x- and y-directions. The default orientation of a patch is horizontal (i.e., it's normal is in the +z direction).</td><td>PRIMITIVE_TYPE_PATCH </td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_triangle.html">Triangle</a></td><td>Triangular polygon specified by its three vertices.</td><td>PRIMITIVE_TYPE_TRIANGLE </td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_voxel.html">Voxel</a></td><td>Parallelpiped or rectangular prism. A voxel is specified by the (x,y,z) coordinate of its center and by the lenghts of its sides in the x-, y-, and z-directions. The default orientation of a voxel is axis-aligned.</td><td>PRIMITIVE_TYPE_VOXEL </td></tr>
</table>
<p><br  />
</p>
<h2><a class="anchor" id="AddingPrims"></a>
Adding Primitives</h2>
<p>Primitives are referenced by their 'universal uinique identifier' or UUID. When a function is called to add a primitive to the context, a UUID is returned that can be used later to reference the primitive. Objects can be formed simply by storing a group of UUIDs corresponding to the primitives that make up the object.</p>
<p>Each primitive type has a different function that is used to add it to the Context, which are detailed in the table below.</p>
<table class="doxtable">
<tr>
<th>Primitive</th><th>Adder function </th></tr>
<tr>
<td><a class="el" href="classhelios_1_1_patch.html">Patch</a></td><td><ul>
<li>
<a class="el" href="group__primitives.html#gafaae593d52d284c5aab98e29cee0cd76">addPatch( vec3 center, vec2 size )</a> </li>
<li>
<a class="el" href="group__primitives.html#ga148090c69c7b04bbfbae4eed2443a235">addPatch( vec3 center, vec2 size, SphericalCoord rotation )</a> </li>
<li>
<a class="el" href="classhelios_1_1_context.html#a7ead8162aab12a399925aa89a6f9007c">addPatch( vec3 center, vec2 size, SphericalCoord rotation, RGBcolor color )</a>  </li>
<li>
<a class="el" href="group__primitives.html#ga953a329d019e3c91948b139215c748af">addPatch( vec3 center, vec2 size, SphericalCoord rotation, const char* texture_file )</a> </li>
<li>
<a class="el" href="group__primitives.html#ga542e67cc428fb707452c216091a7f24f">addPatch( vec3 center, vec2 size, SphericalCoord rotation, const char* texture_file, vec2 uv_center, vec2 uv_size )</a> </li>
</ul>
<br  />
  </td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_triangle.html">Triangle</a></td><td><ul>
<li>
<a class="el" href="group__primitives.html#ga2a78a464a4c7ef3375a0ced2f1005b77">addTriangle( vec3 vertex0, vec3 vertex1, vec3 vertex2 )</a> </li>
<li>
<a class="el" href="group__primitives.html#gafedf69d3c13704eac0b1cdbaedfc2f5c">addTriangle( vec3 vertex0, vec3 vertex1, vec3 vertex2, RGBcolor color )</a> </li>
<li>
<a class="el" href="group__primitives.html#ga6d8025b542a52a8683f76ae292934c76">addTriangle( vec3 vertex0, vec3 vertex1, vec3 vertex2, const char* texture_file, vec2 uv0, vec2 uv1, vec2 uv2 )</a> </li>
</ul>
</td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_voxel.html">Voxel</a></td><td><ul>
<li>
<a class="el" href="group__primitives.html#ga5c3476d33e4c6125276bcae114b49b10">addVoxel( vec3 center, vec3 size )</a> </li>
<li>
<a class="el" href="group__primitives.html#gab03110bd9b0a7d4bdfedfe1e7881b6b0">addVoxel( vec3 center, vec3 size, float rotation )</a> </li>
</ul>
</td></tr>
</table>
<h3><a class="anchor" id="AddingPatch"></a>
Adding Patches</h3>
<p>Patches are added by specifying the (x,y,z) coordinate of its center, the lengths of its sides in the x- and y-directions, and optionally its spherical rotation (see <a class="el" href="_a_p_i.html#Coord">Coordinate System</a>) and r-g-b color. The following is an example of using the 'addPatch' function to add a simple patch:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    Context context;

    vec3 center = make_vec3(0,0,1);
    vec2 size = make_vec2(1,1);

    uint UUID; //universal unique identifier
    UUID = context.addPatch( center, size );

 }</code></pre> </div><p>This will add the Patch shown below, with the default orientation of horizontal. (Note that the addition of the checkerboard ground and the '<a class="el" href="class_visualizer.html">Visualizer</a>' plugin is needed to replicate this image, which is not shown in the example code.)</p>
<div class="image">
<img src="Patch.png" alt=""/>
<div class="caption">
Patch geometric primitive.</div></div>
<p>The patch can also be rotated by adding the optional SphericalCoord argument:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec3 center = make_vec3(0,0,1);
 vec2 size = make_vec2(1,1);
 SphericalCoord rotation = make_SphericalCoord(0.25*M_PI,0.5*M_PI);
 context.addPatch( center, size, rotation );</code></pre> </div><p>This will first rotate the patch by 0.25 <img class="formulaInl" alt="$\pi$" src="form_5.png" width="11" height="8"/> rad about the x-axis such that its normal is pointing toward the +y direction, THEN it will apply a clockwise azimuthal rotation of 0.5 <img class="formulaInl" alt="$\pi$" src="form_5.png" width="11" height="8"/> rad such that its normal is pointing in the +x direction (which will be its final orientation). Note that in order to have more control over rotations, it is recommended to use the Primitive::rotate() function (see "Primitive Transformations" section below).</p>
<h3><a class="anchor" id="AddingTriangle"></a>
Adding Triangles</h3>
<p>Triangles are added by specifying the (x,y,z) coordinates of the triangle's three vertices, and optionally its r-g-b color. The following is an example of using the 'addTriangle()' function to add a simple triangle:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    Context context;

    vec3 v0 = make_vec3(-0.5,-0.5,1);
    vec3 v1 = make_vec3(0.5,-0.5,1);
    vec3 v2 = make_vec3(0,0.5,1);

    uint UUID; //universal unique identifier
    UUID = context.addTriangle( v0, v1, v2, RGB::red );

 }</code></pre> </div><p>This will add the Triangle shown below. (Note that the addition of the checkerboard ground and the '<a class="el" href="class_visualizer.html">Visualizer</a>' plugin is needed to replicate this image, which is not shown in the example code.)</p>
<div class="image">
<img src="Triangle.png" alt=""/>
<div class="caption">
Triangle geometric primitive.</div></div>
<p>An important note for triangles is that the normal direction of the triangle follows the right-hand rule: use your right hand to connect each of the vertices in the order specified, and your thumb will point in the normal direction. This is illustrated in the figure below.</p>
<div class="image">
<img src="triangle_right-hand-rule.jpeg" alt=""/>
<div class="caption">
Right-hand rule to determine triangle normal direction based on the three vertices 0, 1, and 2.</div></div>
<h3><a class="anchor" id="AddingVoxel"></a>
Adding Voxels</h3>
<p>Voxels are added by specifying the (x,y,z) coordinate of its center, the lengths of its sides in the x-, y-, and z-directions, and optionally its spherical rotation (see <a class="el" href="_a_p_i.html#Coord">Coordinate System</a>) and r-g-b color. The following is an example of using the 'addVoxel()' function to add a simple voxel:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    Context context;

    vec3 center = make_vec3(0,0,1);
    vec3 size = make_vec3(1,1,1);

    uint UUID; //universal unique identifier
    UUID = context.addVoxel( center, size, RGB::red );

 }</code></pre> </div><p>This will add the Voxel shown below, with the default orientation of horizontal. (Note that the addition of the checkerboard ground and the 'visualizer' plugin is needed to replicate this image, which is not shown in the example code.)</p>
<div class="image">
<img src="Voxel.png" alt=""/>
<div class="caption">
Voxel geometric primitive.</div></div>
<p>The voxel can also be rotated by adding the optional SphericalCoord argument:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec3 center = make_vec3(0,0,1);
 vec3 size = make_vec3(1,1,1);
 rotation = 0.25*M_PI;
 context.addVoxel( center, size, rotation, RGB::red );</code></pre> </div><h2><a class="anchor" id="PrimTransform"></a>
Primitive Transformations</h2>
<p>After primitives have been added to the Context, their position, size, and orientation can be further modified through transformations.</p>
<p>All primitives have member functions Primitive::scale(), Primitive::translate(), and Primitive::rotate() which modify the size, position, and orientation of the primitive, respectively. The Primitive::scale() function takes a vec3 that denotes a scaling factor to apply in each Cartesian direction (x,y,z). The Primitive::translate() function moves the primitive based on values provided by a vec3 that specifies the distance to translate in the x-, y-, and z-directions.</p>
<p>The Primitive::rotate() function rotates the primitive about an axis through and angle specified in radians. To rotate about one of the x-, y-, or z-axes, the function can be supplied a string of 'x', 'y', or 'z', respectively. The primitive can also be rotated about an arbitrary axis described by a unit vector argument.</p>
<p>It is important to note that the order that transformations are applied is important. Each transformation is applied based on the primitives current state. Rotating a primitive centered about the origin will cause the primitive to rotate about its own center. However, if a primitive is first translated then rotated, the primitive will be rotated about the origin, which does not necessarily coincide with the primitive's center if it has been translated.</p>
<h2><a class="anchor" id="PrimProps"></a>
Primitive Properties</h2>
<p>All primitives have a common set of data that can be accessed by the same set of functions. These functions are accessed through a pointer to the primitive:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> uint UUID; //universal unique identifier
 UUID = context.addVoxel( center, size, RGB::red );

 Primitive* prim = context.getPrimitivePointer(UUID);

 float area = prim-&gt;getArea();</code></pre> </div><p>or a shorthand would be</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> uint UUID; //universal unique identifier
 float area = context.getPrimitivePointer(UUID)-&gt;getArea();</code></pre> </div><p>The table below gives a list of all availalbe primitive functions.</p>
<table class="doxtable">
<tr>
<th>Property</th><th>Getter Function </th></tr>
<tr>
<td>UUID</td><td><a class="el" href="classhelios_1_1_primitive.html#a19ef6bf8ace2e8328c0c22f700b6a23d">getUUID()</a> </td></tr>
<tr>
<td>Primitive Type</td><td><a class="el" href="classhelios_1_1_primitive.html#a8c2b266129af6ed7bd20415506272501">getType()</a> </td></tr>
<tr>
<td>Surface Area</td><td><a class="el" href="classhelios_1_1_primitive.html#a2e140af864e6dcb56d6ea5f85fef8f49">getArea()</a> </td></tr>
<tr>
<td>Normal Vector</td><td><a class="el" href="classhelios_1_1_primitive.html#a0b57d12757d213978d5e0eec30c6eeb4">getNormal()</a> </td></tr>
<tr>
<td>Affine Transformation Matrix</td><td><a class="el" href="classhelios_1_1_primitive.html#ac2f1ded5ace6e33830a5dc2bdf4e554c">getTransformationMatrix()</a> </td></tr>
<tr>
<td>Vertex Coordinates (x,y,z)</td><td><a class="el" href="classhelios_1_1_primitive.html#a12b57475648525eaca7e0c225ea0122b">getVertices()</a> </td></tr>
<tr>
<td>Diffuse R-G-B color code</td><td><a class="el" href="classhelios_1_1_primitive.html#a123006f09b743e84be76774c38dc823c">getColor()</a> </td></tr>
<tr>
<td>Diffuse R-G-B-A color code</td><td><a class="el" href="classhelios_1_1_primitive.html#a9840f3bdafa5439387f358580e5bf779">getColorRGBA()</a> </td></tr>
<tr>
<td>Check whether the primitive has a texture map</td><td><a class="el" href="classhelios_1_1_primitive.html#a117f166ead4099f6fdca0c4b77bf2a6c">hasTexture()</a> </td></tr>
<tr>
<td>Get texture map data</td><td><a class="el" href="classhelios_1_1_primitive.html#a04a5dc84bbdda84e2b8f60ce0d1d4793">getTexture()</a> </td></tr>
<tr>
<td>Name of texture map file</td><td><a class="el" href="classhelios_1_1_primitive.html#a5e088b5721b2e47ba049f5d3ed551c4e">getTextureFile()</a> </td></tr>
<tr>
<td>Get the (u,v) coordinates of the texture mapping</td><td><a class="el" href="classhelios_1_1_primitive.html#a233531e06c5fcd60aa9bf1570b9e7ff5">getTextureUV()</a> </td></tr>
</table>
<p>Some primitives have special functions specific to that type of primitive. For example, one may want to query the volume of a Voxel. These special functions are tabulated below. In order to use the special functions, you must get a pointer to the primitive type (e.g., Patch, Triangle, etc.) not the primitive. This is done using the 'get[*]Pointer' functions (e.g., <a class="el" href="group__primitives.html#gac94ca5a68dec6379c427c551bf551254">getPatchPointer()</a>). The example below illustrates how to get a pointer to a Patch, which is then used to query its size.</p>
<table class="doxtable">
<tr>
<th>Primitive Type</th><th>Pointer Getter Function</th><th>Special Function </th></tr>
<tr>
<td>Patch</td><td><a class="el" href="group__primitives.html#gac94ca5a68dec6379c427c551bf551254">getPatchPointer()</a></td><td><ul>
<li>
<a class="el" href="classhelios_1_1_patch.html#aa3cb7f673e4d06d7434e7c6b9791d0bb">getSize()</a> </li>
<li>
<a class="el" href="classhelios_1_1_patch.html#a96b19dc5697196e2431f7dbfd4739303">getCenter()</a> </li>
</ul>
</td></tr>
<tr>
<td>Triangle</td><td><a class="el" href="group__primitives.html#ga0333afa4e2eb64ff88fa0b63bdef0707">getTrianglePointer()</a></td><td><ul>
<li>
<a class="el" href="classhelios_1_1_triangle.html#adc18079107231d0e5840f289877f9ac1">getVertex( int number )</a> </li>
<li>
<a class="el" href="classhelios_1_1_triangle.html#a3377c8211592e7ac167c8a8f2d416185">getSolidFraction( )</a> </li>
</ul>
</td></tr>
<tr>
<td>Voxel</td><td><a class="el" href="group__primitives.html#ga5a69de049b1e95e628761977b2882d06">getVoxelPointer()</a></td><td><ul>
<li>
<a class="el" href="classhelios_1_1_voxel.html#ac47af697c6ceacecd71352dcd6928110">getSize()</a> </li>
<li>
<a class="el" href="classhelios_1_1_voxel.html#a43874b0b593bffa4d7f63250639412e7">getCenter()</a> </li>
<li>
<a class="el" href="classhelios_1_1_voxel.html#aefb000290902e18fa4407a6cd9a4d00e">getVolume()</a> </li>
</ul>
</td></tr>
</table>
<p><br  />
</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    <code></code>// Initialize the Context
    Context context;

    <code></code>// Add 'Patch' primitive 
    vec3 center = make_vec3(0,0,1);
    vec2 size = make_vec2(1,1);
    uint UUID = context.addPatch( center, size, RGB::red );

    <code></code>// Get pointer to Patch
    Patch* patch = context.getPatchPointer(UUID);

    <code></code>// Get Patch size
    vec2 SIZE = patch-&gt;getSize();  

 }</code></pre> </div><h2><a class="anchor" id="Transforms"></a>
Primitive Transformations</h2>
<p>Primitives can be transformed after they are added to the Context, which includes translation, rotation, and scaling. <b>The order in which the transformations are applied is important!</b> In general, you'll usually want to scale the primitive first, then rotate, then translate. If, for example, you rotate the primitive, then scale it, it will scale the rotated primitive in the (x,y,z) directions which is not the same as scaling the primitive pre-rotation.</p>
<p>A transformation can either be applied by calling the function from the primitive's pointer, or directly from the Context if you have a single or vector of UUIDs. These functions are tabulated below.</p>
<p>Calling from a pointer to a primitive:</p>
<table class="doxtable">
<tr>
<th>Transformation</th><th>Function </th></tr>
<tr>
<td>Translate in x, y, or z direction</td><td>translate( vec3 shift ) </td></tr>
<tr>
<td>Rotate about x, y, or z axis</td><td><a class="el" href="classhelios_1_1_primitive.html#acf6651311abec476bdfd8c7f7d4d00aa">rotate( float rot, const char* axis )</a> </td></tr>
<tr>
<td>Rotate about arbitrary axis</td><td>rotate( float rot, vec3 axis ) </td></tr>
<tr>
<td>Scale in x, y, or z direction</td><td>scale( vec3 S ) </td></tr>
</table>
<p>Below is a code example of applying a transformation using a pointer to the primitive:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    <code></code>// Initialize the Context
    Context context;

    <code></code>// Add 'Patch' primitive 
    vec3 center(0,0,1);
    vec2 size = make_vec2(1,1);
    uint UUID = context.addPatch( center, size );

    <code></code>// Apply translation
    vec3 translation(1,0,0);
    context.getPrimitivePointer(UUID)-&gt;translate( translation );

 }</code></pre> </div><p>Calling directly from the Context using a single UUID:</p>
<table class="doxtable">
<tr>
<th>Transformation</th><th>Function </th></tr>
<tr>
<td>Translate in x, y, or z direction</td><td>translatePrimitive( uint UUID, vec3 shift ) </td></tr>
<tr>
<td>Rotate about x, y, or z axis</td><td><a class="el" href="classhelios_1_1_context.html#a5e5dd3ef9b56a0bf148ed9d315422fe7">rotatePrimitive( uint UUID, float rot, const char* axis )</a> </td></tr>
<tr>
<td>Rotate about arbitrary axis</td><td>rotatePrimitive( uint UUID, float rot, vec3 axis ) </td></tr>
<tr>
<td>Scale in x, y, or z direction</td><td>scalePrimitive( uint UUID, vec3 S ) </td></tr>
</table>
<p>Below is a code example of applying a transformation from the Context using a single primitive UUID:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    <code></code>// Initialize the Context
    Context context;

    <code></code>// Add 'Patch' primitive 
    vec3 center(0,0,1);
    vec2 size = make_vec2(1,1);
    uint UUID = context.addPatch( center, size );

    <code></code>// Apply translation
    vec3 translation(1,0,0);
    context.translatePrimitive( UUID, translation );

 }</code></pre> </div><p>This can also be accomplished by passing a vector of UUIDs to the transformation function to apply the transformations to many primitives at once using these functions:</p>
<table class="doxtable">
<tr>
<th>Transformation</th><th>Function </th></tr>
<tr>
<td>Translate in x, y, or z direction</td><td>translatePrimitive( vector&lt;uint&gt; UUIDs, vec3 shift ) </td></tr>
<tr>
<td>Rotate about x, y, or z axis</td><td>rotatePrimitive( vector&lt;uint&gt; UUIDs, float rot, const char* axis ) </td></tr>
<tr>
<td>Rotate about arbitrary axis</td><td>rotatePrimitive( vector&lt;uint&gt; UUIDs, float rot, vec3 axis ) </td></tr>
<tr>
<td>Scale in x, y, or z direction</td><td>scalePrimitive( vector&lt;uint&gt; UUIDs, vec3 S ) </td></tr>
</table>
<h2><a class="anchor" id="Texture"></a>
Texture Mapping</h2>
<p>Images can be overlaid on patches and triangles through a process called <a href="https://en.wikipedia.org/wiki/Texture_mapping">texture mapping</a>. There are typically two reasons for doing this. One is simply for visualization purposes, as it easily allows for complex coloring of a surface by coloring a surface according to an image. The other is to create a more complex shape by removing a portion of the primitive surface according to the transparency channel of an image. Each of these cases are described in detail below.</p>
<h2><a class="anchor" id="TextureColor"></a>
Coloring Primitives by Texture Map</h2>
<p>Patches: To color a Patch based on an image, simply pass the path to a PNG or JPEG image to the appropriate argument of the addPatch() command. Note that the path should either be absolute, or relative to the directory where the executable will be run (typically the &lsquo;build&rsquo; directory).</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec3 center = make_vec3(0,0,1);
 vec2 size = make_vec2(2.5,1);
 SphericalCoord rotation = make_SphericalCoord(0,0);
 context.addPatch( center, size, rotation, "PSL_logo_white.png");</code></pre> </div><p><br  />
 </p>
<div class="image">
<img src="Patch_textured.png" alt=""/>
<div class="caption">
Patch geometric primitive colored by texture map.</div></div>
<p>By default, the image is stretched to fill the entire surface of the patch. Alternatively, custom mapping coordinates can be supplied.</p>
<p>Patches:</p>
<div class="image">
<img src="AspenLeaf_uv_patch.png" alt=""/>
<div class="caption">
.</div></div>
<p>Triangles:</p>
<div class="image">
<img src="AspenLeaf_uv_triangle.png" alt=""/>
<div class="caption">
.</div></div>
<h2><a class="anchor" id="TextureMask"></a>
Masking Primitives by Image Transparency Channel</h2>
<p>If the image provided for texture mapping has a transparency channel, the portion of the primitive that is transparent will automatically be removed, and the rest of the non-transparent portion of the primitive will be colored according to the image. Note that only PNG images are supported, since JPEG images do not have transparency. An example is given below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    <code></code>// Initialize the Context
    Context context;

    <code></code>// Add 'Patch' primitive with transparency mask
    vec3 center = make_vec3(0,0,1);
    vec2 size = make_vec2(1,1);

    uint UUID = context.addPatch( center, size, make_SphericalCoord(0,0), "GrapeLeaf.png" );

 }</code></pre> </div><div class="image">
<img src="AlphaMask_leaf.png" alt=""/>
<div class="caption">
Rectangular patch masked by an image with a transparency channel.</div></div>
<div style="padding:10px;background-color:#FF6666 ;line-height:1.2;"> A very important performance note when using texture-masked primitives with transparency: When a texture-masked primitive with transparency is added to the Context, the solid surface area of the primitive is calculated by determining which fraction of pixels are non-transparent. This is a computationally expensive process when the image is high resolution (e.g., millions of pixels).</div><div style="padding:10px;background-color:#FF6666 ;line-height:1.2;"> If you are adding many identical primitives/objects with transparency, it is better to add it to the Context one time, then copy and translate it as many times as you need. An example of this is given in the code below. </div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    <code></code>// Initialize the Context
    Context context;

    <code></code>// Add 'Patch' primitive with transparency mask
    <code></code>// We will add a patch at the origin and with unit size, and copy it multiple times
    vec3 center = make_vec3(0,0,0);
    vec2 size = make_vec2(1,1);

    uint UUID = context.addPatch( center, size, make_SphericalCoord(0,0), "GrapeLeaf.png" );

    for( int i=0; i&lt;10; i++ ){

          uint UUID_copy = context.copyPrimitive(UUID);

          vec3 position = make_vec3( i*3, 0, 0 );

     context.translatePrimitive( position );

    }

    <code></code>// Let's delete the original "template"
    context.deletePrimitive(UUID);

 }</code></pre> </div><h2><a class="anchor" id="Compound"></a>
Compound Geometry</h2>
<p>The Context has functions to rapidly generate various shapes, which consist of many primitives. These functions simply add the primitives needed to make the specified geometry, and return a vector of UUIDs corresponding to each of the primitives. The important distinction between these functions and those to add "Objects" (described below) is that Objects retain information about the overall 3D object such as the radius of the sphere.</p>
<p>Functions for adding compound geometry are listed below.</p>
<table class="doxtable">
<tr>
<th>Geometry </th><th>Description </th><th>Adder function(s) </th><th>Example  </th></tr>
<tr>
<td>Tile </td><td>Patch subdivided into uniform grid of sub-patches. </td><td><ul>
<li>
addTile( const vec3 center, const vec2 size, const SphericalCoord rotation, const int2 subdiv )  </li>
<li>
addTile( const vec3 center, const vec2 size, const SphericalCoord rotation, const int2 subdiv, const RGBcolor color )  </li>
<li>
addTile( const vec3 center, const vec2 size, const SphericalCoord rotation, const int2 subdiv, const char* texturefile )  </li>
</ul>
</td><td><div class="image">
<img src="Tile.png" alt=""/>
</div>
  </td></tr>
<tr>
<td>Sphere </td><td>Spherical object tesselated with Triangle primitives. </td><td><ul>
<li>
addSphere( uint Ndivs, vec3 center, float radius )  </li>
<li>
addSphere( uint Ndivs, vec3 center, float radius, RGBcolor color )  </li>
<li>
addSphere( uint Ndivs, vec3 center, float radius, const char* texturefille )  </li>
</ul>
</td><td><div class="image">
<img src="Sphere.png" alt=""/>
</div>
  </td></tr>
<tr>
<td>Tube </td><td>Cylindrical tube object tesselated with Triangle primitives. Follows a specified path and can change radius along its length. </td><td><ul>
<li>
addTube( uint Ndivs, vector&lt;vec3&gt; nodes, vector&lt;float&gt; radius ) </li>
<li>
addTube( uint Ndivs, vector&lt;vec3&gt; nodes, vector&lt;float&gt; radius, RGBcolor color ) </li>
</ul>
</td><td><div class="image">
<img src="Tube.png" alt=""/>
</div>
  </td></tr>
<tr>
<td>Box </td><td>Rectangular prism object tesselated with Patch primitives. </td><td><ul>
<li>
addBox( vec3 center, vec3 size, int3 subdiv )  </li>
<li>
addBox( vec3 center, vec3 size, int3 subdiv, RGBcolor color )  </li>
<li>
addBox( vec3 center, vec3 size, int3 subdiv, RGBcolor color, bool reverse_normals )  </li>
</ul>
</td><td><div class="image">
<img src="Box.png" alt=""/>
</div>
  </td></tr>
<tr>
<td>Disk </td><td>Ellipsoidal disk object tesselated with Triangle primitives. </td><td><ul>
<li>
<a class="el" href="group__compoundobjects.html#gaad3d5c21579728fa839c6a95514991bb">addDisk( uint Ndiv, helios::vec3 center, helios::vec2 size )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#ga3c0d84f0ade9148214d0a7ec5e574aeb">addDisk( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#gac774b33822ae284009dc761146e37670">addDisk( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation, helios::RGBcolor color )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#gaf323d883bfc3392b3817fce85a5205ae">addDisk( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation, helios::RGBAcolor color )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#gaee1c741715ce7367c8198e573b9684ec">addDisk( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation, const char* texture_file )</a>  </li>
</ul>
</td><td><div class="image">
<img src="Disk.png" alt=""/>
</div>
  </td></tr>
</table>
<h2><a class="anchor" id="Objects"></a>
Objects</h2>
<p>Objects are geometries consisting of many primitive elements. The critical difference between "Objects" and the compound objects described above is that Objects retain information about the overall geometry such as length, radius, etc., and have many sub-functions for manipulating them and assigning data. This is often useful when you want to know information about the overall object or want to manipulate the entire object in unison.</p>
<p>Functions for adding objects return a uint that serves as a unique identifier for the object, which can be used for later reference and manipulation. Functions for adding objects are listed in the table below.</p>
<table class="doxtable">
<tr>
<th>Object </th><th>Description </th><th>Adder function(s) </th><th>Example  </th></tr>
<tr>
<td>Tile </td><td>Patch subdivided into uniform grid of sub-patches. </td><td><ul>
<li>
addTileObject( const vec3 center, const vec2 size, const SphericalCoord rotation, const int2 subdiv )  </li>
<li>
addTileObject( const vec3 center, const vec2 size, const SphericalCoord rotation, const int2 subdiv, const RGBcolor color )  </li>
<li>
addTileObject( const vec3 center, const vec2 size, const SphericalCoord rotation, const int2 subdiv, const char* texturefile )  </li>
</ul>
</td><td><div class="image">
<img src="Tile.png" alt=""/>
</div>
  </td></tr>
<tr>
<td>Sphere </td><td>Spherical object tesselated with Triangle primitives. </td><td><ul>
<li>
addSphere( uint Ndivs, vec3 center, float radius )  </li>
<li>
addSphereObject ( uint Ndivs, vec3 center, float radius, RGBcolor color )  </li>
<li>
addSphereObject ( uint Ndivs, vec3 center, float radius, const char* texturefile )  </li>
</ul>
</td><td><div class="image">
<img src="Sphere.png" alt=""/>
</div>
  </td></tr>
<tr>
<td>Tube </td><td>Cylindrical tube object tesselated with Triangle primitives. Follows a specified path and can change radius along its length. </td><td><ul>
<li>
addTubeObject( uint Ndivs, vector&lt;vec3&gt; nodes, vector&lt;float&gt; radius ) </li>
<li>
addTubeObject( uint Ndivs, vector&lt;vec3&gt; nodes, vector&lt;float&gt; radius, RGBcolor color ) </li>
</ul>
</td><td><div class="image">
<img src="Tube.png" alt=""/>
</div>
  </td></tr>
<tr>
<td>Box </td><td>Rectangular prism object tesselated with Patch primitives. </td><td><ul>
<li>
addBoxObject( vec3 center, vec3 size, int3 subdiv )  </li>
<li>
addBoxObject( vec3 center, vec3 size, int3 subdiv, RGBcolor color )  </li>
<li>
addBoxObject( vec3 center, vec3 size, int3 subdiv, RGBcolor color, bool reverse_normals )  </li>
</ul>
</td><td><div class="image">
<img src="Box.png" alt=""/>
</div>
  </td></tr>
<tr>
<td>Disk </td><td>Ellipsoidal disk object tesselated with Triangle primitives. </td><td><ul>
<li>
<a class="el" href="group__compoundobjects.html#ga064d0343ca8556d8a6a00c7cdce3bf0d">addDiskObject( uint Ndiv, helios::vec3 center, helios::vec2 size )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#ga826e790ed5999e168c22ddcc7e57e514">addDiskObject( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#gadcc9c858b2c3afe1430ff4013f69b780">addDiskObject( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation, helios::RGBcolor color )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#gaed3cc3a47ff86ea9dfcf70cd9b295b23">addDiskObject( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation, helios::RGBAcolor color )</a>  </li>
<li>
<a class="el" href="group__compoundobjects.html#ga4fb358731a06c9eafc267e9e6f522577">addDiskObject( uint Ndiv, helios::vec3 center, helios::vec2 size, helios::SphericalCoord rotation, const char* texture_file )</a>  </li>
</ul>
</td><td><div class="image">
<img src="Disk.png" alt=""/>
</div>
  </td></tr>
<tr>
<td>Cone </td><td>Tapered cylinder/cone object tesselated with triangles. </td><td><ul>
<li>
addConeObject( uint Ndivs, helios::vec3 node0, helios::vec3 node1, float radius0, float radius1 ) </li>
<li>
addConeObject( uint Ndivs, helios::vec3 node0, helios::vec3 node1, float radius0, float radius1, RGBcolor color ) </li>
<li>
addConeObject( uint Ndivs, helios::vec3 node0, helios::vec3 node1, float radius0, float radius1, const char* texturefile ) </li>
</ul>
</td><td><div class="image">
<img src="Cone.png" alt=""/>
</div>
  </td></tr>
</table>
<p>Similar to individual primitives, objects have functions to perform transformations on the entire object in unison. These functions are member functions of the <a class="el" href="classhelios_1_1_compound_object.html">helios::CompoundObject</a> class. As with primitives, you can use the identifier to an object to get its pointer, from which you can access member functions.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> uint objID; //unique identifier to object
 objID = context.addTileObject( center, size, rotation, make_int2(2,2) );

 CompoundObject* object = context.getObjectPointer(objID);

 float area = object-&gt;getArea();</code></pre> </div><p>or a shorthand would be</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> uint objID; //object identifier
 float area = context.getObjectPointer(objID)-&gt;getArea();</code></pre> </div><p>The table below gives a list of availalbe Object functions.</p>
<table class="doxtable">
<tr>
<th>Property</th><th>Getter Function </th></tr>
<tr>
<td>Object ID</td><td><a class="el" href="classhelios_1_1_compound_object.html#a28c85b0cf4dee51dd7997b7b78e4f442">getObjectID()</a> </td></tr>
<tr>
<td>Object Type</td><td><a class="el" href="classhelios_1_1_compound_object.html#ab07473392ca1e4c439c909c83cc9730b">getObjectType()</a> </td></tr>
<tr>
<td>Primitive Count</td><td><a class="el" href="classhelios_1_1_compound_object.html#a0eb06d37710a7dc9f5b915fc33f191a0">getPrimitiveCount()</a> </td></tr>
<tr>
<td>Member Primitive UUIDs</td><td><a class="el" href="classhelios_1_1_compound_object.html#ab3973a7c8ccb1aa0ce3f21ffe461ef7b">getPrimitiveUUIDs()</a> </td></tr>
<tr>
<td>Member Primitive Check</td><td><a class="el" href="classhelios_1_1_compound_object.html#ae06ed1275c9ba5ed5ed59b08bdfd1216">doesObjectContainPrimitive()</a> </td></tr>
<tr>
<td>Object Center</td><td><a class="el" href="classhelios_1_1_compound_object.html#aff66ca85a22d7f8a2501039e2e7183a7">getObjectCenter()</a> </td></tr>
<tr>
<td>Surface Area</td><td><a class="el" href="classhelios_1_1_compound_object.html#a8bb518f6166e2a2831a68a7626787ac1">getArea()</a> </td></tr>
<tr>
<td>Diffuse R-G-B color code</td><td><a class="el" href="classhelios_1_1_compound_object.html#ad1dabb5e1b8329b2963e7365b171bb1d">getColor()</a> </td></tr>
<tr>
<td>Diffuse R-G-B color code</td><td><a class="el" href="classhelios_1_1_compound_object.html#ad5dfe90d0bdcc6eaf0d084731766e4ef">getRGBColor()</a> </td></tr>
<tr>
<td>Diffuse R-G-B-A color code</td><td><a class="el" href="classhelios_1_1_compound_object.html#a61f89abf65150849aaeb3ccab628676e">getRGBAColor()</a> </td></tr>
<tr>
<td>Override Texture</td><td><a class="el" href="classhelios_1_1_compound_object.html#a247e9f55e89ce5bb4621cc395069a20d">overrideTextureColor()</a> </td></tr>
<tr>
<td>Use Texture</td><td><a class="el" href="classhelios_1_1_compound_object.html#ad40fa98ddefc9ba9d24cd45ca0df44d5">useTextureColor()</a> </td></tr>
</table>
<p>Objects can be translated and rotated using functions similar to that of primitives:</p>
<table class="doxtable">
<tr>
<th>Transformation</th><th>Function </th></tr>
<tr>
<td>Translate in x, y, or z direction</td><td>translate( vec3 shift ) </td></tr>
<tr>
<td>Rotate about x, y, or z axis</td><td><a class="el" href="classhelios_1_1_compound_object.html#a8d0020a8a8f7a1f931b9cd8cb341ee84">rotate( float rot, const char* axis )</a> </td></tr>
<tr>
<td>Rotate about arbitrary axis</td><td>rotate( float rot, vec3 axis ) </td></tr>
</table>
<p>Some objects have special functions specific to that type of object, which are listed below. In order to access these functions, you need to get a pointer to that type of object using thhe appropriate get[*]ObjectPointer() function.</p>
<table class="doxtable">
<tr>
<th>Object Type</th><th>Pointer Getter Function</th><th>Special Function </th></tr>
<tr>
<td>Tile</td><td><a class="el" href="classhelios_1_1_context.html#ad2b762dd7b31126150c6e6dc350a3914">getTileObjectPointer()</a></td><td><ul>
<li>
<a class="el" href="classhelios_1_1_tile.html#aa8daadd99bd57f647837e26890fcfeac">getSize()</a> </li>
<li>
<a class="el" href="classhelios_1_1_tile.html#a18178d0280f8ecc1149663558947ca06">getCenter()</a> </li>
<li>
<a class="el" href="classhelios_1_1_tile.html#a4f4198becfe3cafd989b5aa6cd21d5cf">getSubdivisionCount()</a> </li>
<li>
<a class="el" href="classhelios_1_1_tile.html#aaea21403039646db33792c95be929afd">getVertices()</a> </li>
<li>
<a class="el" href="classhelios_1_1_tile.html#ab8c70daf8c14bc60caf499b5adce301c">getNormal()</a> </li>
<li>
<a class="el" href="classhelios_1_1_tile.html#a94deb25ac31abc1eb02dfe6913b4546f">getTextureUV()</a> </li>
<li>
<a class="el" href="classhelios_1_1_tile.html#ab8d33ae89fd78503d4c170124b2c4b23">scale()</a> </li>
</ul>
</td></tr>
<tr>
<td>Sphere</td><td><a class="el" href="classhelios_1_1_context.html#a8ed7580efa323c0f5e53e97d00e16c85">getSphereObjectPointer()</a></td><td><ul>
<li>
<a class="el" href="classhelios_1_1_sphere.html#a925a4eccca10735eb3f9ec03ad87abf1">getRadius()</a> </li>
<li>
<a class="el" href="classhelios_1_1_sphere.html#a48eada17c3dab899a91158f1424518d6">getCenter()</a> </li>
<li>
<a class="el" href="classhelios_1_1_sphere.html#a152107e463d6765ba27ff8f3ab737711">getSubdivisionCount()</a> </li>
<li>
<a class="el" href="classhelios_1_1_sphere.html#a2bbde5e83811a1cbf0c2ac8824beaaf7">scale()</a> </li>
</ul>
</td></tr>
<tr>
<td>Tube</td><td><a class="el" href="classhelios_1_1_context.html#ab26f963c75aa99d797a43860479910b0">getTubeObjectPointer()</a></td><td><ul>
<li>
<a class="el" href="classhelios_1_1_tube.html#ab55e8f7d7a948941027f169d714e365b">getNodes()</a> </li>
<li>
<a class="el" href="classhelios_1_1_tube.html#a29823b956371d22b35add97fc6831cab">getNodeRadii()</a> </li>
<li>
<a class="el" href="classhelios_1_1_tube.html#abf9bb1153b3607a5d616aafeee06e43e">getSubdivisionCount()</a> </li>
<li>
<a class="el" href="classhelios_1_1_tube.html#a94d8db6948991b7470c1cbc4af248e31">scale()</a> </li>
</ul>
</td></tr>
<tr>
<td>Box</td><td><a class="el" href="classhelios_1_1_context.html#a1ecbb5a8cfa6764bade6e0650d2f6990">getBoxObjectPointer()</a></td><td><ul>
<li>
<a class="el" href="classhelios_1_1_box.html#afd79ee17402ab6367896fe8278800f34">getSize()</a> </li>
<li>
<a class="el" href="classhelios_1_1_box.html#a96e72a40ff113d6a6b463fe8c60b672a">getCenter()</a> </li>
<li>
<a class="el" href="classhelios_1_1_box.html#a6f25b211d8740257329f841cda737a4f">getSubdivisionCount()</a> </li>
<li>
<a class="el" href="classhelios_1_1_box.html#a6b2557d765e824d4f202bd6790926076">scale()</a> </li>
</ul>
</td></tr>
<tr>
<td>Disk</td><td><a class="el" href="classhelios_1_1_context.html#a17c1256a1f57fbae1f34e04b66b76ca8">getDiskObjectPointer()</a></td><td><ul>
<li>
<a class="el" href="classhelios_1_1_disk.html#a23c03df1f2e351659a08420a41a74eb5">getSize()</a> </li>
<li>
<a class="el" href="classhelios_1_1_disk.html#ae8ed884a95cbfa2440e3bd9f8e3e4057">getCenter()</a> </li>
<li>
<a class="el" href="classhelios_1_1_disk.html#ace21fc719d39ebebf3c78c14298c7c74">getSubdivisionCount()</a> </li>
<li>
<a class="el" href="classhelios_1_1_disk.html#a38c3a10cf352ffcf78ad1596f2414ace">scale()</a> </li>
</ul>
</td></tr>
<tr>
<td>Cone</td><td><a class="el" href="classhelios_1_1_context.html#a3221051ea9c1025e8fb00d9dec01839f">getConeObjectPointer()</a></td><td><ul>
<li>
<a class="el" href="classhelios_1_1_cone.html#ab9c1d73c568b8926cc4d97c700bdfd8c">getNodes()</a> </li>
<li>
<a class="el" href="classhelios_1_1_cone.html#a8bd53050e5e2e1e5b428e5245d34c036">getNode()</a> </li>
<li>
<a class="el" href="classhelios_1_1_cone.html#adc5370734810e4b526bf0d42e143ecf8">getNodeRadii()</a> </li>
<li>
<a class="el" href="classhelios_1_1_cone.html#a957ca80e79fd4bb3bb14dbcec85959df">getNodeRadius()</a> </li>
<li>
<a class="el" href="classhelios_1_1_cone.html#a051a2c5760d53a6c0b95f66cab9cbf73">getSubdivisionCount()</a> </li>
<li>
<a class="el" href="classhelios_1_1_cone.html#a60fc92fbb15149017956449123c0e4d0">getAxisUnitVector()</a> </li>
<li>
<a class="el" href="classhelios_1_1_cone.html#ada36b3fe4850f16c4dfa58c38a8da80c">getLength()</a> </li>
<li>
<a class="el" href="classhelios_1_1_cone.html#aaefa3caee5b8e46ca46650031d0bee0a">scaleLength()</a> </li>
<li>
<a class="el" href="classhelios_1_1_cone.html#ad40b7cda9baac86be967058736b2bb78">scaleGirth()</a> </li>
</ul>
</td></tr>
</table>
<h1><a class="anchor" id="Data"></a>
Data Structures</h1>
<p>Data structures that are moved in and out of plugins are managed by the Context. There are two types of Context data structures that serve different purposes:</p>
<ul>
<li>
<b>Primitive Data</b> - is a piece of data associated with a given primitive. An example of this may be the reflectivity or temperature of a given primitive. Primitive data is flexible in that it can have different data types, variable lengths, and can be different for different primitives. For example, voxels could have a data value specifying the attenuation coefficient, but the attenuation coefficient would not be relevant for patches so they would not have this piece of data. A given primitive could have an array of 10 integers as its data. However, primitive data is limited to one-dimensional arrays, and mapping to multidimensional data is left to the user. </li>
<li>
<b>Global Data</b> - is similar to 'primitive data', except that global data is not necessarily associated with any particular primitive. An example of global data might be the solar radiative flux incident on the earth. </li>
</ul>
<p>Implementation of data structure usage is detailed for each type of structure below.</p>
<p>Only certain data types are supported for primitive and global data (below), which are referenced using their enumeration type.</p>
<table class="doxtable">
<tr>
<th>Data type</th><th>Enumeration (HeliosDataType) </th></tr>
<tr>
<td> <font face="courier" color="green">int</font></td><td>HELIOS_TYPE_INT </td></tr>
<tr>
<td> <font face="courier" color="green">uint</font></td><td>HELIOS_TYPE_UINT </td></tr>
<tr>
<td> <font face="courier" color="green">float</font></td><td>HELIOS_TYPE_FLOAT </td></tr>
<tr>
<td> <font face="courier" color="green">double</font></td><td>HELIOS_TYPE_DOUBLE </td></tr>
<tr>
<td> <font face="courier" color="green">vec2</font></td><td>HELIOS_TYPE_VEC2 </td></tr>
<tr>
<td> <font face="courier" color="green">vec3</font></td><td>HELIOS_TYPE_VEC3 </td></tr>
<tr>
<td> <font face="courier" color="green">vec4</font></td><td>HELIOS_TYPE_VEC4 </td></tr>
<tr>
<td> <font face="courier" color="green">int2</font></td><td>HELIOS_TYPE_INT2 </td></tr>
<tr>
<td> <font face="courier" color="green">int3</font></td><td>HELIOS_TYPE_INT3 </td></tr>
<tr>
<td> <font face="courier" color="green">int4</font></td><td>HELIOS_TYPE_INT4 </td></tr>
<tr>
<td> <font face="courier" color="green">std::string</font></td><td>HELIOS_TYPE_STRING <br  />
 </td></tr>
</table>
<h2><a class="anchor" id="PrimData"></a>
Primitive Data</h2>
<h3><a class="anchor" id="SetPrimData"></a>
Setting Primitive Data Values</h3>
<p>Primitive data values can be scalar or a one-dimensional array of values.</p>
<p>Primitive data is set for a given primitive via the Context using the <a class="el" href="classhelios_1_1_context.html#ac7677094a3bbcb62506ce461d982af1d">setPrimitiveData()</a> function. Example use of this function for scalar data is given below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    Context context;

    uint UUID = context.addPatch( center, size, RGB::red );

    float eps = 0.9;
    context.setPrimitiveData(UUID,"emissivity",eps);
 }</code></pre> </div><p>Alternatively, primitive data can be set from a pointer to the primitive using <a class="el" href="classhelios_1_1_primitive.html#a9cf890cc9751acf7e50a97e311b9d786">setPrimitiveData()</a>:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> Primitive* prim = context-&gt;getPrimitivePointer(UUID);

 float eps = 0.9;
 prim.setPrimitiveData("emissivity",eps);</code></pre> </div><p>Reference <a class="el" href="group__primitives.html#ga0a2a576098472e45b2b0a242d4d4dadf">getPrimitivePointer()</a> for further information on how to get a pointer to primitives.</p>
<p>There are multiple ways of setting vector primitive data. One method uses STL vectors to pass the data to the <a class="el" href="classhelios_1_1_context.html#ac7677094a3bbcb62506ce461d982af1d">setPrimitiveData()</a>, and another is accomplished using a pointer to a standard C vector. Both of these equivalent methods are illustrated below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    Context context;

    vec3 center(0,0,0);
    vec2 size(1,1);

    uint UUID = context.addPatch( center, size );

    std::vector&lt;float&gt; A;
    A.push_back(2.3);
    A.push_back(9.2);
    context.setPrimitiveData(UUID,"somedataA",HELIOS_TYPE_FLOAT,A.size(),&amp;A[0]);

    float B[2];
    B[0] = 2.3;
    B[1] = 9.2;
    context.setPrimitiveData(UUID,"somedataB",HELIOS_TYPE_FLOAT,2,&amp;B[0]);

 }</code></pre> </div><h3><a class="anchor" id="GetPrimData"></a>
Getting Primitive Data Values</h3>
<p>If primitive data is a scalar value, it can be retrieved for a given primitive via the Context using the <a class="el" href="classhelios_1_1_context.html#a2144eea981e4030c973287ce2c38315e">getPrimitiveData</a> function:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    Context context;

    vec3 center(0,0,0);
    vec2 size(1,1);

    uint UUID = context.addPatch( center, size );

    float eps = 0.9;
    context.setPrimitiveData(UUID,"emissivity",eps);

    float emissivity;
    context.getPrimitiveData(UUID,"emissivity",emissivity);

 }</code></pre> </div><p>In the above example, the value of 'emissivity' is 0.9.</p>
<p>For a vector of primitive data, use the getPrimitiveData_v function. Note that the 'getPrimitiveData_v' function can always be used regardless of whether the data is scalar or vector valued. If the data is scalar and 'getPrimitiveData_v' is used, the function will simply return a vector structure of length 1.</p>
<h3><a class="anchor" id="PrimDataHelpers"></a>
Primitive Data Query Functions</h3>
<p>It is often necessary to query information about primitive data. The following table lists functions used to query primitive data information. Note that the query functions are called through a pointer to the primitive, not directly from the Context (see example below).</p>
<table class="doxtable">
<tr>
<th>Function</th><th>Description </th></tr>
<tr>
<td><a class="el" href="classhelios_1_1_primitive.html#aa2241f7d999a12a9b47949116a3ff886">doesPrimitiveDataExist( const char* label )</a></td><td>Check whether primitive data named 'label' exists for the primitive. </td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_primitive.html#aa7a7907e183212cd1d1a4cfd631bb310">getPrimitiveDataType( const char* label )</a></td><td>Get the helios::HeliosDataType for the primitive. </td></tr>
<tr>
<td><a class="el" href="classhelios_1_1_primitive.html#af5eabf3325bfd0e097b6326ed69cc781">getPrimitiveDataSize( const char* label )</a></td><td>Get the length/size of the primitive data named 'label'. </td></tr>
</table>
<p><br  />
</p>
<p><br  />
 </p>
<p><br  />
</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

    Context context;

    vec3 center(0,0,0);
    vec2 size(1,1);

    uint UUID = context.addPatch( center, size );

    float eps = 0.9;
    context.setPrimitiveData(UUID, "emissivity", eps);

    Primitive* prim context.getPrimitive(UUID);
    if( prim-&gt;doesPrimitiveDataExist("emissivity") ){
       HeliosDataType type = prim-&gt;getPrimitiveDataType("emissivity");
       uint L = prim-&gt;getPrimitiveDataSize("emissivity");
    }

 }</code></pre> </div><h2><a class="anchor" id="GlobalData"></a>
Global Data</h2>
<p>Global data is similar to primitive data, except that it does not correspond to any particular primitive, rather it is a single instance of a certain data structure. The functions used to create global data within the Context are essentially the same as those used to create primitive data, except they do not take a primitive UUID as an argument (because they do not correspond to primitives).</p>
<h2><a class="anchor" id="DataTimeseries"></a>
Data Timeseries</h2>
<p>Timeseries - or data points corresponding to discrete points in time - can be managed by the Context. This typically corresponds to data that is measured by a sensor. Timeseries data points are added to the Context by giving the value of the data point, along with <a class="el" href="structhelios_1_1_date.html">Date</a> and <a class="el" href="structhelios_1_1_time.html">Time</a> vectors. An example is given below to manualy add 15-min timeseries data to the Context.</p>
<p>Data in the timeseries can be accessed either via the queryTimeseriesData() function by giving the index of the data point, or by giving a date and time. To loop through all data in the timeseries, we can query the length of the timeseries and make a for-loop.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 using namespace helios;

 int main( void ){

       <code></code>// Initialize the Context
       Context context;

       <code></code>// Add data to timeseries
       Date date;
       Time time;

       date = make_Date( 2, 1, 2000 ); <code></code>// 2 Jan. 2000

       time = make_Time( 13, 00, 00 ); <code></code>// 13:00:00
       context.addTimeseriesData( "temperature", 301.23, date, time ); <code></code>// index #0

       time = make_Time( 13, 15, 00 ); <code></code>// 13:15:00
       context.addTimeseriesData( "temperature", 301.92, date, time ); <code></code>// index #1

       time = make_Time( 13, 30, 00 ); <code></code>// 13:30:00
       context.addTimeseriesData( "temperature", 302.56, date, time ); <code></code>// index #2

       time = make_Time( 13, 45, 00 ); <code></code>// 13:45:00
       context.addTimeseriesData( "temperature", 303.05, date, time ); <code></code>// index #3

       float T;
       T = context.queryTimeseriesData( "temperature", 1 ); <code></code>// Here, T = 301.92

       time = make_Time( 13, 15, 00 );
       T = context.queryTimeseriesData( "temperature", date, time ); <code></code>// Also here, T = 301.92

       for( uint i=0; i&lt;context.getTimeseriesLength("temperature"); i++ ){
        T = context.queryTimeseriesData( "temperature", i );
            time = context.getTimeseriesTime( "temperature", i );
        printf("Temperature at time %02d:%02d:%02d is %f\n", time.hour, time.minute, time.second );                          
    }

 }</code></pre> </div><p>Typically, data is not entered manually, but rather through an XML file (see Reading XML Files for information).</p>
<p>It is often necessary to get the number of data points in a given timeseries, which can be accomplished with the command:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> uint N = context.getTimeseriesLength( "temperature" );</code></pre> </div> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
