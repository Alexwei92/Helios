<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>.: LiDAR Point Cloud Plugin Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Helios_logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">.
   &#160;<span id="projectnumber">v1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="_plug_ins.html">Plug-ins</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">LiDAR Point Cloud Plugin Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#LiDARissues">Known Issues</a></li>
<li class="level1"><a href="#LiDARintro">Introduction</a></li>
<li class="level1"><a href="#LiDARdepends">Dependencies</a></li>
<li class="level1"><a href="#LiDARConstructor">Class Constructor</a></li>
<li class="level1"><a href="#LiDARbg">Background information</a><ul><li class="level2"><a href="#LiDARcoord">Coordinates and scan pattern</a></li>
<li class="level2"><a href="#ScanMetadata">Scan metadata</a></li>
<li class="level2"><a href="#AddHits">Hit point data</a></li>
</ul>
</li>
<li class="level1"><a href="#ScanIO">Loading scan data from file</a></li>
<li class="level1"><a href="#LiDARgrid">Establishing grid cells</a></li>
<li class="level1"><a href="#LiDARprocess">Processing LiDAR data</a><ul><li class="level2"><a href="#LiDARtri">Hit point triangulation</a></li>
<li class="level2"><a href="#LiDARleafarea">Calculating leaf area for each grid cell</a></li>
<li class="level2"><a href="#LiDARresonstruction">Plant reconstruction</a></li>
</ul>
</li>
<li class="level1"><a href="#LiDARvis">Visualizing results</a></li>
<li class="level1"><a href="#LiDARoutput">Writing results to file</a></li>
</ul>
</div>
<div class="textblock"><div class="image">
<img src="LiDAR.png" alt=""/>
</div>
<p><br  />
<br  />
 </p>
<table class="doxtable">
<tr>
<th>Dependencies</th><td>NVIDIA CUDA 9.0+ <br  />
gcc/g++ 5.5+ <br  />
<a class="el" href="class_visualizer.html" title="Class for visualization of simulation results.">Visualizer</a> plug-in </td></tr>
<tr>
<th>CMakeLists.txt</th><td>set( PLUGINS "lidar" ) </td></tr>
<tr>
<th>Header File</th><td>#include "LiDAR.h" </td></tr>
<tr>
<th>Class</th><td><a class="el" href="class_li_d_a_rcloud.html">LiDARcloud</a> </td></tr>
</table>
<h1><a class="anchor" id="LiDARissues"></a>
Known Issues</h1>
<ul>
<li>The LiDAR plug-in requires the <a class="el" href="class_visualizer.html" title="Class for visualization of simulation results.">Visualizer</a> plug-in to be loaded in the CMakeLists.txt file.</li>
</ul>
<h1><a class="anchor" id="LiDARintro"></a>
Introduction</h1>
<p>The LiDAR plugin is used to process terrestrial LiDAR data into information that is useful for plant models. For example, this may be to determine leaf area and angle distributions at the voxel scale, or to reconstruct individual leaves and add them to the Context.</p>
<h1><a class="anchor" id="LiDARdepends"></a>
Dependencies</h1>
<table class="doxtable">
<caption>Installing dependent packages</caption>
<tr>
<th>Package</th><td><div class="image">
<img src="apple-logo.jpg" alt=""/>
</div>
 </td><td><div class="image">
<img src="unix-logo.png" alt=""/>
</div>
 </td><td><div class="image">
<img src="windows-logo.jpg" alt=""/>
</div>
  </td></tr>
<tr>
<td>NVIDIA CUDA 5.0+ </td><td>Mac OSX:<br  />
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"><code>$ brew install Caskroom/cask/cuda</code></div> </td><td>Debian/Ubuntu:<br  />
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"><code>$ sudo apt-get install cuda</code></div></td><td>Unknown  </td></tr>
</table>
<h1><a class="anchor" id="LiDARConstructor"></a>
Class Constructor</h1>
<table class="doxtable">
<tr>
<th>Constructors </th></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html">LiDARcloud( void )</a> </td></tr>
</table>
<p>The <a class="el" href="class_li_d_a_rcloud.html">LiDARcloud</a> class contains point cloud data, and is used to perform processing operations on the data. The class constructor does not take any arguments.</p>
<h1><a class="anchor" id="LiDARbg"></a>
Background information</h1>
<h2><a class="anchor" id="LiDARcoord"></a>
Coordinates and scan pattern</h2>
<p>The algorithms associated with the LiDAR plug-in work with data obtained from a rectangular scan pattern. In this scan pattern, points are sampled at equally spaced intervals in both the zenithal ( <img class="formulaInl" alt="$\theta$" src="form_3.png" width="8" height="12"/>) and azimuthal ( <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/>) directions. At a given azimuthal angle, some range of zenithal angles are consecutively scanned, which represents a "scan line". Each scan line starts at some zenithal angle <img class="formulaInl" alt="$\theta$" src="form_3.png" width="8" height="12"/><sub>min</sub> and ends at some zenithal angle <img class="formulaInl" alt="$\theta$" src="form_3.png" width="8" height="12"/><sub>max</sub>. After recording a scan line at the first azimuthal angle <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>min</sub>, the scanner incrementally moves to the next adjacent azimuthal scan direction and records the next scan line until it reaches the azimuthal angle <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>max</sub>.</p>
<p>The number of zenithal points within each scan line is given by <img class="formulaInl" alt="$\mathrm{N}_{\theta}$" src="form_28.png" width="18" height="15"/>, and the total number of scan lines (i.e., number of individual azimuthal directions) is is given by <img class="formulaInl" alt="$\mathrm{N}_{\varphi}$" src="form_29.png" width="20" height="17"/>.</p>
<p>Angles are typically specified as degrees. Distance units are arbitrary, but must be used consistently.</p>
<div class="image">
<img src="CoordinateSystem.jpeg" alt=""/>
<div class="caption">
Scan pattern: the scanner traverses some range of zenithal and azimuthal angles to explore a portion of the spherical space surrounding the scanner.</div></div>
<div class="image">
<img src="HitSchematic.jpeg" alt=""/>
<div class="caption">
For each scan direction, the scanner records the (x,y,z) Cartesian position of the point of intersection between the ray path and the object's surface. Each Cartesian position corresponds to spherical coordinate (zenith,azimuth) representing the scan direction.</div></div>
<div class="image">
<img src="RectangularScan.png" alt=""/>
<div class="caption">
The rectangular scan pattern creates quadrilateral polygons between four neighboring points.</div></div>
<h2><a class="anchor" id="ScanMetadata"></a>
Scan metadata</h2>
<p>Each scan has a set of parameters or "metadata" that must be specified in order to process the data. Some parameters are optional, while some are required. The following metadata is needed to define the overall scan itself, in addition to individual scan hit points:</p>
<table class="doxtable">
<tr>
<th>Metadata</th><th>Description</th><th>Default behavior </th></tr>
<tr>
<td>Origin</td><td>(x,y,z) coordinate of the scanner. This is the position where the scanner rays are sent from.</td><td>None: REQUIRED </td></tr>
<tr>
<td>N<sub>theta</sub></td><td>Number of scan points in the theta (zenithal) direction, i.e., number of rows in scan point table.</td><td>None: REQUIRED </td></tr>
<tr>
<td><img class="formulaInl" alt="$\theta$" src="form_3.png" width="8" height="12"/><sub>min</sub> (degrees)</td><td>Minimum scan theta (zenital) angle. <img class="formulaInl" alt="$\theta$" src="form_3.png" width="8" height="12"/><sub>min</sub>=0 if the scan starts from upward vertical, <img class="formulaInl" alt="$\theta$" src="form_3.png" width="8" height="12"/><sub>min</sub>=90 is the scan starts from horizontal, etc. </td><td>0 </td></tr>
<tr>
<td><img class="formulaInl" alt="$\theta$" src="form_3.png" width="8" height="12"/><sub>max</sub> (degrees)</td><td>Maximum scan theta (zenital) angle. <img class="formulaInl" alt="$\theta$" src="form_3.png" width="8" height="12"/><sub>max</sub>=90 if the scan ends at horizontal, <img class="formulaInl" alt="$\theta$" src="form_3.png" width="8" height="12"/><sub>min</sub>=180 is the scan ends at downward vertical, etc. </td><td>180 </td></tr>
<tr>
<td>N<sub>phi</sub></td><td>Number of scan points in the phi (azimuthal) direction, i.e., number of rows in scan point table.</td><td>None: REQUIRED </td></tr>
<tr>
<td><img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>min</sub> (degrees)</td><td>Minimum scan phi (azimuthal) angle. <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>min</sub>=0 if the scan starts pointing in the +x direction, <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>min</sub>=90 if the scan starts pointing in the +y direction, etc. </td><td>0 </td></tr>
<tr>
<td><img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>max</sub> (degrees)</td><td>Maximum scan phi (azimuthal) angle. <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>max</sub>=90 if the scan ends pointing in the +y direction, <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>min</sub>=180 if the scan ends pointing in the -x direction, etc. NOTE: <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>max</sub> could be greater than 360 if <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>min</sub>&gt;0 and the scanner makes a full rotation in the in the azimuthal direction, in which case <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>max</sub>= <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/><sub>min</sub>+360.</td><td>360 </td></tr>
<tr>
<td>translation</td><td>Global (x,y,z) translation to be applied to entire scan, including the origin and all hit ponts.</td><td>No translation. </td></tr>
<tr>
<td>rotation (degrees)</td><td>Global spherical rotation (theta,phi) to be applied to the entire scan, including the origin and all hit ponts.</td><td>No rotation. </td></tr>
</table>
<h2><a class="anchor" id="AddHits"></a>
Hit point data</h2>
<p>In addition to scan metadata, the data collected by the scan itself must also be added to the plug-in. At a minimum, this consists of the Cartesian (x,y,z) coordinates of each hit in the scan. Additionally, hit points may also have an associated r-g-b color value, or some other scalar data value such as reflectance or temperature. For the processing algorithms to work, the scan direction associated with each hit point must also be known. This can be specified as a ( <img class="formulaInl" alt="$\theta$" src="form_3.png" width="8" height="12"/>, <img class="formulaInl" alt="$\varphi$" src="form_4.png" width="9" height="11"/>) spherical coordinate, or using the row (i.e., index in the scanline: 1... <img class="formulaInl" alt="$\mathrm{N}_\theta$" src="form_30.png" width="18" height="15"/>) and column (i.e., scanline index: 1... <img class="formulaInl" alt="$\mathrm{N}_\varphi$" src="form_31.png" width="20" height="17"/>).</p>
<table class="doxtable">
<tr>
<th>Data</th><th>Description</th><th>Default behavior </th></tr>
<tr>
<td>(x,y,z) position</td><td>(x,y,z) coordinate of the hit point relative to the scan origin (i.e., the location of the scanner head).</td><td>None: REQUIRED </td></tr>
<tr>
<td>ray direction</td><td>Spherical direction (theta, phi) of the ray. Ray directions are used to construct the scan hit table. There could be multiple hits for a given ray direction if a full-waveform instrument is used in multiple return mode.</td><td>Calculated automatically using the scanner origin and the (x,y,z) hit position. </td></tr>
<tr>
<td>color</td><td>r-g-b color of scan hit point.</td><td>red </td></tr>
<tr>
<td>data</td><td>Floating point data values associated with the hit point. This could be reflectance, temperature, etc.</td><td>No data created. </td></tr>
</table>
<h1><a class="anchor" id="ScanIO"></a>
Loading scan data from file</h1>
<p>Scan metadata is typically specified by loading an XML file containing the relevant metadata for each scan. The XML file specifies the path to an ASCII text file that contains the data for each scan. The code below gives a sample XML file for loading multiple scans. As specified in the metadata table above, not all entries are required.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> &lt;helios&gt;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>   &lt;scan&gt;
     &lt;filename&gt; /path/to/data/file.xyz &lt;/filename&gt;
     &lt;ASCII_format&gt; zenith azimuth x y z r255 g255 b255 &lt;/ASCII_format&gt;
     &lt;origin&gt; 0 0 0 &lt;/origin&gt;
     &lt;size&gt; 2500 4500 &lt;/size&gt;
     &lt;thetaMin&gt; 30 &lt;/thetaMin&gt; &lt;!-- OPTIONAL - default: 0 --&gt;
     &lt;thetaMax&gt; 130 &lt;/thetaMax&gt; &lt;!-- OPTIONAL - default: 180 --&gt;
     &lt;phiMin&gt; 0 &lt;/phiMin&gt; &lt;!-- OPTIONAL - default: 0 --&gt;
     &lt;phiMax&gt; 360 &lt;/phiMax&gt; &lt;!-- OPTIONAL - default: 360 --&gt;
     &lt;translation&gt; 1.2 1.5 -10.2 &lt;/translation&gt; &lt;!-- OPTIONAL - default: 0 0 0 --&gt;
     &lt;rotation&gt; 20 180 &lt;/rotation&gt; &lt;!-- OPTIONAL - default: 0 0 --&gt;
     &lt;distanceFilter&gt; 50 &lt;/distanceFilter&gt; &lt;!-- OPTIONAL - default: Infinity --&gt;
     &lt;reflectance&gt; 1300 &lt;/reflectance&gt; &lt;!-- OPTIONAL - user-defined data --&gt;
   &lt;/scan&gt;
&lt;/helios&gt;</code></pre></div><p>The ASCII text file containing the data is a plain text file, where each row corresponds to a hit point and each column is some data value associated with that hit point. The "ASCII_format" tag defines the column format of the ASCII text file (in this case, file.xyz). Each entry in the list specifies the meaning of each column. Possible fields are listed in the table below:</p>
<table class="doxtable">
<tr>
<th>Label</th><th>Description</th><th>Default behavior </th></tr>
<tr>
<td>x</td><td>x-component of the (x,y,z) Cartesian coordinate of the hit point.</td><td>None: REQUIRED </td></tr>
<tr>
<td>y</td><td>y-component of the (x,y,z) Cartesian coordinate of the hit point.</td><td>None: REQUIRED </td></tr>
<tr>
<td>z</td><td>z-component of the (x,y,z) Cartesian coordinate of the hit point.</td><td>None: REQUIRED </td></tr>
<tr>
<td>zenith (or zenith_rad)</td><td>Zenithal angle (degrees) of scan ray direction corresponding to the hit point. If "theta_rad" is used, theta has units of radians rather than degrees.</td><td>Calculated from scan origin and hit (x,y,z). </td></tr>
<tr>
<td>azimuth (or phi_rad)</td><td>Azithal angle (degrees) of scan ray direction corresponding to the hit point. If "phi_rad" is used, phi has units of radians rather than degrees.</td><td>Calculated from scan origin and hit (x,y,z). </td></tr>
<tr>
<td>r (or r255)</td><td>red component of (r,g,b) hit color. If "r" tag is used, r is a floating point value and 0&lt;r&lt;1. If "r255" is used, r is an integer and 0&lt;r&lt;255.</td><td>r=1 or r255=255 </td></tr>
<tr>
<td>g (or g255)</td><td>green component of (r,g,b) hit color. If "g" tag is used, g is a floating point value and 0&lt;g&lt;1. If "g255" is used, g is an integer and 0&lt;g&lt;255.</td><td>g=0 or g255=0 </td></tr>
<tr>
<td>b (or b255)</td><td>blue component of (r,g,b) hit color. If "b" tag is used, b is a floating point value and 0&lt;b&lt;1. If "b255" is used, b is an integer and 0&lt;b&lt;255.</td><td>b=0 or b255=0 </td></tr>
<tr>
<td>(label)</td><td>User-defined floating-point data value. "label" can be any string describing data. For example, "reflectance", "temperature", etc. </td><td>N/A </td></tr>
</table>
<p>The XML file can be automatically loaded into the point cloud using the loadXML() function, as illustrated below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
  #include "LiDAR.h"</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>  using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>  int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     LiDARcloud pointcloud; //Initialize the LiDAR point cloud</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     pointcloud.loadXML("/path/to/file.xml");</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>}</code></pre></div><h1><a class="anchor" id="LiDARgrid"></a>
Establishing grid cells</h1>
<p>Rectangular grid cells are used as the basis for processing point cloud data. For example, total leaf area (or leaf area density) may be calculated for each grid cell. Grid cells or "voxels" are parallelpiped volumes. The top and bottom faces are always horizontal, but the cells can be rotated in the azimuthal direction.</p>
<p>Grid cells are defined by specifying the (x,y,z) position of its center, and the size of the cell in the x, y, and z directions. Additional optional information can also be provided for grid cells, which are detailed below.</p>
<table class="doxtable">
<tr>
<th>Tag</th><th>Description</th><th>Default behavior </th></tr>
<tr>
<td>center</td><td>(x,y,z) Cartesian coordinates of cell center.</td><td>None: required. </td></tr>
<tr>
<td>size</td><td>Length of cell sides in x, y, and z directions.</td><td>None: required. </td></tr>
<tr>
<td>rotation</td><td>Azimuthal rotation of the cell in degrees.</td><td>0 </td></tr>
<tr>
<td>Nx</td><td>Grid cell subdivisions in the x-direction.</td><td>1 </td></tr>
<tr>
<td>Ny</td><td>Grid cell subdivisions in the y-direction.</td><td>1 </td></tr>
<tr>
<td>Nz</td><td>Grid cell subdivisions in the z-direction.</td><td>1 </td></tr>
</table>
<p>The grid cell subdivisions options allow the cells to be easily split up into a grid of smaller cells. For example, Nx=Ny=Nz=3 would create 27 grid cells similar to a "Rubik's cube".</p>
<p>Grid cell options can be specified in an XML file using the tags listed in the table above. Multiple grid cells are added by simply adding more &lt;grid&gt;...&lt;/grid&gt; groups to the XML file.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> &lt;grid&gt;
    &lt;center&gt; 0 0 0.5 &lt;/center&gt;
    &lt;size&gt; 1 1 1 &lt;/size&gt;
    &lt;rotation&gt; 30 &lt;/rotation&gt; &lt;!-- OPTIONAL - default: 0 --&gt;
    &lt;Nx&gt; 3 &lt;/Nx&gt; &lt;!-- OPTIONAL - default: 1 --&gt;
    &lt;Ny&gt; 3 &lt;/Ny&gt; &lt;!-- OPTIONAL - default: 1 --&gt;
    &lt;Nz&gt; 3 &lt;/Nz&gt; &lt;!-- OPTIONAL - default: 1 --&gt;
 &lt;/grid&gt;</code></pre></div><h1><a class="anchor" id="LiDARprocess"></a>
Processing LiDAR data</h1>
<h2><a class="anchor" id="LiDARtri"></a>
Hit point triangulation</h2>
<p>A triangulation between adjacent points is typically required for any of the available data processing algorithms. In the triangulation, adjacent hit points are connected to form a mesh of triangular solid surfaces. The algorithm for performing this triangulation is described in detail in <a href="dx.doi.org/doi:10.1016/j.rse.2017.03.011">Bailey and Mahaffee (2017a)</a>.</p>
<p>There are two possible options to be specified when performing the triangulation. A required option is <img class="formulaInl" alt="$L_{max}$" src="form_32.png" width="33" height="15"/>, which is the maximum allowable length of a triangle side. This parameter prevents triangles from connecting adjacent leaves (i.e., we only want triangles to be formed with neighboring points on the same leaf). Typically we want <img class="formulaInl" alt="$L_{max}$" src="form_32.png" width="33" height="15"/> to be much larger than the spacing between adjacent hit points, and much smaller than the characteristic length of a leaf. For example, <a href="dx.doi.org/doi:10.1016/j.rse.2017.03.011">Bailey and Mahaffee (2017a)</a> used 5cm for a cottonwood tree.</p>
<p>Another optional parameter is the maximum allowable aspect ratio of a triangle, which is the ratio of the length of the longest triangle side to the shortest triangle side. This has a similar effect as the <img class="formulaInl" alt="$L_{max}$" src="form_32.png" width="33" height="15"/> parameter, and works better in some cases.</p>
<p>The following code sample illustrates how to perform a triangulation.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 #include "LiDAR.h"</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    LiDARcloud pointcloud; //Initialize the LiDAR point cloud</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    pointcloud.loadXML("/path/to/file.xml");  //Load the XML file</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    pointcloud.triangulateHitPoints( 0.05, 5 ); //Perform triangulation with Lmax=0.05 and maximum aspect ratio of 5</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre></div><h2><a class="anchor" id="LiDARleafarea"></a>
Calculating leaf area for each grid cell</h2>
<p>Using the triangulation and defined grid cells, the plug-in can calculate the leaf area (and leaf area density) for each grid cell. The algorithm for calculating leaf area is described in detail in <a href="dx.doi.org/doi:10.1088/1361-6501/aa5cfd">Bailey and Mahaffee (2017b)</a>.</p>
<p>Performing the calculations is simple and requires no inputs, which is illustrated with the following code sample. Note that the leaf area calculation requires that the triangulation has been performed beforehand. If no triangulation is available, the plug-in will assume a uniformly distributed leaf angle orientation ( <img class="formulaInl" alt="$G=0.5$" src="form_33.png" width="51" height="12"/>). The leaf area calculation also requires that at least one grid cell was defined.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 #include "LiDAR.h"</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    LiDARcloud pointcloud; //Initialize the LiDAR point cloud</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    pointcloud.loadXML("/path/to/file.xml");  //Load the XML file</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    pointcloud.triangulateHitPoints( 0.05, 5 ); //Perform triangulation with Lmax=0.05 and maximum aspect ratio of 5</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    pointcloud.calculateLeafAreaGPU(); //Calculate leaf area for each grid cell</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre></div><h2><a class="anchor" id="LiDARresonstruction"></a>
Plant reconstruction</h2>
<p>A leaf-by-leaf reconstruction can be performed for the plant of interest using the method described in <a href="https://www.sciencedirect.com/science/article/pii/S0034425718300191?via%3Dihub">Bailey and Ochoa (2018)</a>. The reconstruction utilizes the triangulation and leaf area computations to ensure the correct leaf angle and area distributions on average, and thus requires that these routines have been run before performing the reconstruction.</p>
<p>There are two types of available reconstructions. One is a triangular reconstruction that directly uses triangles resulting from the triangulation to produce the reconstruction. The advantage is that it doesn not require any assumption about the shape of the leaf and can give a more direct reconstruction in some cases, however this reconstruction is typically not recommended as it often results in many small triangle groups that don't necessarily resemble actual leaves. This reconstruction is performed using the leafReconstructionTriangular() function, whose arguments are thresholds for the minimum and maximum area of reconstructed triangular leaf groups.</p>
<p>The other type of reconstruction is the "Alpha Mask" reconstruction, which replaces the triangle groups with a "prototype" leaf (which is an alpha mask). This ensures that all reconstructed leaves are representative of an actual leaf in terms of shape and size. This reconstruction is performed using the leafReconstructionAlphaMask() function. This function's arguments, in addition to area thresholds, are the aspect ratio of the prototype leaf (length along midrib divided by width perpendicular to midrib) and the path to a PNG image file to be used for the leaf alpha mask.</p>
<p>There is a function that can automatically add all reconstructed elements (triangles or alpha masks) to the Helios Context, which is addLeafReconstructionToContext().</p>
<p>Below is an example of performing a reconstruction using alpha masks and adding the alpha masks to the Context.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 #include "LiDAR.h"</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    LiDARcloud pointcloud; //Initialize the LiDAR point cloud</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    pointcloud.loadXML("/path/to/file.xml");  //Load the XML file</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    pointcloud.triangulateHitPoints( 0.05, 5 ); //Perform triangulation with Lmax=0.05 and maximum aspect ratio of 5</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    pointcloud.calculateLeafAreaGPU(); //Calculate leaf area for each grid cell</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    pointcloud.leafReconstructionAlphaMask( 0.001, 0.02, "plugins/visualizer/textures/ElmLeaf.png" ); //Perform the reconstruction</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    Context context; //Initialize the Context</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    pointcloud.addLeafReconstructionToContext( &amp;context );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre></div><h1><a class="anchor" id="LiDARvis"></a>
Visualizing results</h1>
<p>Results can be visualized using the <a class="el" href="class_visualizer.html" title="Class for visualization of simulation results.">Visualizer</a> plug-in for Helios. There are two possible means for doing so. First, is to add the relevant geometry to the Context, then visualize primitives in the Context using the <a class="el" href="class_visualizer.html" title="Class for visualization of simulation results.">Visualizer</a>. This works for the triangulation and plant reconstructions, but cannot be used to visualize just the point cloud since there is no "point" primitive in the Context. The next section describes how to accomplish this.</p>
<p>The second option is to add any geometry directly to the <a class="el" href="class_visualizer.html" title="Class for visualization of simulation results.">Visualizer</a>. There are several functions build in to the LiDAR plug-in that can to this automatically, which are listed below.</p>
<table class="doxtable">
<tr>
<th>Function</th><th>Description </th></tr>
<tr>
<td>LiDARcloud::addHitsToVisualizer( Visualizer * visualizer, const uint pointsize )</td><td>Add all hits in the point cloud to the visualizer. </td></tr>
<tr>
<td>LiDARcloud::addGridToVisualizer( Visualizer * visualizer )</td><td>Add all grid cells to the visualizer, which are displayed as translucent voxels. </td></tr>
<tr>
<td>LiDARcloud::addTrianglesToVisualizer( Visualizer * visualizer )</td><td>Add all triangles to the visualizer, which are colored by the r-g-b color value. </td></tr>
<tr>
<td>LiDARcloud::addTrianglesToVisualizer( Visualizer * visualizer, const uint gridcell )</td><td>Add triangles from a specified grid cell to the visualizer, which are colored by the r-g-b color value. </td></tr>
</table>
<p>The following code sample illustrates how to visualize the point cloud.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>  #include "Context.h"
  #include "LiDAR.h"
  #include "Visualizer.h"</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>  using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>  int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     LiDARcloud pointcloud; //Initialize the LiDAR point cloud</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     pointcloud.loadXML("/path/to/file.xml");  //Load the XML file</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     Visualizer vis( 1000 ); //Initialize the visualizer</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     pointcloud.addHitsToVisualizer( &amp;vis, 1 );  //Add the hit points to visualizer</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     vis.plotInteractive();</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>  }</code></pre></div><h1><a class="anchor" id="LiDARoutput"></a>
Writing results to file</h1>
<p>Results of data processing can be easily written to file for external analysis. The following table lists these functions. Data is written to an ASCII text file, where each line in the file corresponds to a different data point (e.g., hit point, triangle, etc.).</p>
<table class="doxtable">
<tr>
<th>Function</th><th>Description </th></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#ad030fdddcfa669d6af513eb66a9cbd1a">LiDARcloud::exportTriangleNormals( const char* filename )</a> </td><td>Write the unit normal vectors [nx ny nz] of all triangles formed from triangulation. </td></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#a945639fca5f157ed82847f18134fc4ed">LiDARcloud::exportTriangleNormals( const char* filename, const int gridcell )</a> </td><td>Write the unit normal vectors of triangles formed from triangulation that reside in a specified grid cell. </td></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#a416638f486c4fd2572a9589b69605fe7">LiDARcloud::exportTriangleAreas( const char* filename )</a> </td><td>Write the areas of all triangles formed from triangulation. </td></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#ac9f19878711a4cd53d05e4f4cda60372">LiDARcloud::exportTriangleAreas( const char* filename, const int gridcell )</a> </td><td>Write the areas of triangles formed from triangulation that reside in a specified grid cell. </td></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#a8e8bd43bf3b2c107994fee402c41240f">LiDARcloud::exportLeafAreas( const char* filename )</a> </td><td>Write the leaf area contained within each voxel. Each line of the output file corresponds to the total leaf area within each voxel. </td></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#a6e438fd60af7f54f4d1c09ac64fd7338">LiDARcloud::exportLeafAreaDensities( const char* filename )</a> </td><td>Write the leaf area density of each voxel. Each line of the output file corresponds to the leaf area density of each voxel. </td></tr>
</table>
<p>The following code sample illustrates an example of how to write results to file.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>  #include "Context.h"
  #include "LiDAR.h"</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>  using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>  int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     LiDARcloud pointcloud; //Initialize the LiDAR point cloud</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     pointcloud.loadXML("/path/to/file.xml");  //Load the XML file</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     pointcloud.triangulateHitPoints( 0.05, 5 ); //Perform triangulation with Lmax=0.05 and maximum aspect ratio of 5</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     uint Ncells = pointcloud.getGridCellCount(); //Get the number of grid cells</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>     char f_normals[50], f_areas[50];
     for( uint i=0; i&lt;Ncells; i++ ){ //loop over grid cells
          <code></code>// define strings with output file names
          sprintf(f_normals,"../output/triangle_normals_%d.txt",i);
          sprintf(f_areas,"../output/triangle_areas_%d.txt",i);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>          pointcloud.exportTriangleNormals( f_normals, i );
          pointcloud.exportTriangleAreas( f_areas, i );
     }
     pointcloud.exportLeafAreas( "../output/leaf_areas.txt" );
     pointcloud.exportLeafAreaDensities( "../output/leaf_area_densities.txt" );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>  }</code></pre></div> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
