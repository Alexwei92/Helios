<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Radiation Model Plugin Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Helios_logo_small.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="_plug_ins.html">Plug-ins</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Radiation Model Plugin Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#RadConstructor">RadiationModel Class Constructor</a></li>
<li class="level1"><a href="#RadVarsAndProps">Input/Output Primitive Data</a><ul><li class="level2"><a href="#RadInputData">Input Primitive Data</a></li>
<li class="level2"><a href="#RadOutputData">Output Primitive Data</a></li>
</ul>
</li>
<li class="level1"><a href="#RadUse">Using the Radiation Model Plug-In</a><ul><li class="level2"><a href="#RadConst">Model Class Constructor</a></li>
<li class="level2"><a href="#RadBands">Defining Wavelength Bands</a></li>
<li class="level2"><a href="#RadProps">Radiative Properties</a></li>
<li class="level2"><a href="#RadEmission">Radiative Emission</a><ul><li class="level3"><a href="#RadTwoSided">Single-Sided Emission and Absorption</a></li>
</ul>
</li>
<li class="level2"><a href="#RadSources">External Radiation Sources</a><ul><li class="level3"><a href="#ColSource">Adding Collimated Sources</a></li>
<li class="level3"><a href="#PointSource">Adding Point Sources</a></li>
<li class="level3"><a href="#AmbSource">Adding Diffuse/Ambient Sources</a></li>
</ul>
</li>
<li class="level2"><a href="#RadScatter">Scattering Iterations</a></li>
<li class="level2"><a href="#RadRun">Running Simulations</a></li>
<li class="level2"><a href="#RadSolar">Integrating with the SolarPosition Plug-in</a></li>
<li class="level2"><a href="#RadVis">Visualizing Model Outputs</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><div class="image">
<img src="GreenhouseImage.png" alt="GreenhouseImage.png"/>
</div>
<p><br />
<br />
 </p>
<table class="doxtable">
<tr>
</tr>
</table>
<p><br />
 </p>
<p>Dependencies </p>
<p>NVIDIA CUDA 5.0+  </p>
<p><br />
 </p>
<p>CMakeLists.txt </p>
<p>set( PLUGINS "radiation" )  </p>
<p><br />
 </p>
<p>Header File </p>
<p>#include "RadiationModel.h"  </p>
<p><br />
 </p>
<p>Class </p>
<p><a class="el" href="class_radiation_model.html">RadiationModel</a>  </p>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>Installing dependent packages</caption>
<tr>
</tr>
</table>
<p><br />
 </p>
<p>Package </p>
<div class="image">
<img src="apple-logo.jpg" alt="apple-logo.jpg"/>
</div>
 <div class="image">
<img src="unix-logo.png" alt="unix-logo.png"/>
</div>
  <p><br />
 </p>
<p>NVIDIA CUDA 5.0+ </p>
<p>Mac OSX:<br />
</p><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"><code>$ brew install Caskroom/cask/cuda</code></div> <p>Debian/Ubuntu:**<br />
</p><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"><code>$ sudo apt-get install nvidia-cuda-toolkit</code></div>  <p>** Potential issues:</p><ul>
<li>In Debian, this requires you to enable 'non-free' packages. Follow <a href="http://ask.xmodulo.com/install-nonfree-packages-debian.html">this link</a> for instructions on how to allow non-free packages.</li>
<li>It is possible that your installed compiler is too new for the latest CUDA version. If this is the case, you will get an error while compiling, and you will have to revert to an earlier compiler version. You will have to add a symbolic link from the lower compiler version to /usr/bin/cc, /usr/bin/gcc, /usr/bin/c++, and /usr/bin/g++.</li>
</ul>
<h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>This model simulates the transport of radiative energy for arbitrary wavelength bands using a GPU-accelerated ray-tracing model. The model details are described in <a href="http://dx.doi.org/10.1016/j.ecolmodel.2017.11.022">Bailey (2018)</a>. Briefly, the model uses a reverse ray-tracing approach to simulate emission from primitive elements, collimated radiation sources, and point radiation sources.</p>
<h1><a class="anchor" id="RadConstructor"></a>
RadiationModel Class Constructor</h1>
<table class="doxtable">
<tr>
</tr>
</table>
<p><br />
 </p>
<p>Constructors  </p>
<p><br />
 </p>
<p><a class="el" href="class_radiation_model.html">RadiationModel( helios::Context* context )</a>  </p>
<p>The <a class="el" href="class_radiation_model.html">RadiationModel</a> class is initialized by simply passing a pointer to the Helios context as an argument to the constructor. This gives the class the ability to automatically query model geometry and read/write from/to model data.</p>
<h1><a class="anchor" id="RadVarsAndProps"></a>
Input/Output Primitive Data</h1>
<h2><a class="anchor" id="RadInputData"></a>
Input Primitive Data</h2>
<table class="doxtable">
<tr>
</tr>
</table>
<p><br />
 </p>
<p>Primitive Data </p>
<p>Units </p>
<p>Data Type </p>
<p>Description </p>
<p>Availalbe Plug-ins </p>
<p>Default Value  </p>
<p>temperature </p>
<p>Kelvin </p>
<p> <font face="courier" color="green">float</font> </p>
<p>Primitive surface temperature. <b>NOTE: Only needed if performing emission calculations.</b> </p>
<p>Can be computed by <a class="el" href="class_energy_balance_model.html">EnergyBalanceModel</a> plug-in </p>
<p>300 K  </p>
<p>reflectivity_* </p>
<p>unitless </p>
<p> <font face="courier" color="green">float</font> </p>
<p>Primitive reflectivity for band * (i.e., reflectivity for band 'PAR' would be 'reflectivity_PAR'). </p>
<p>N/A </p>
<p>0  </p>
<p>transmissivity_* </p>
<p>unitless </p>
<p> <font face="courier" color="green">float</font> </p>
<p>Primitive transmissivity for band * (i.e., transmissivity for band 'PAR' would be 'transmissivity_PAR'). </p>
<p>N/A </p>
<p>0  </p>
<p>emissivity_* </p>
<p>unitless </p>
<p> <font face="courier" color="green">float</font> </p>
<p>Primitive emissivity for band * (i.e., emissivity for band 'PAR' would be 'emissivity_PAR'). <b>NOTE: Only needed if performing emission calculations.</b> </p>
<p>N/A </p>
<p>1.0  </p>
<p><br />
 </p>
<h2><a class="anchor" id="RadOutputData"></a>
Output Primitive Data</h2>
<table class="doxtable">
<tr>
</tr>
</table>
<p><br />
 </p>
<p>Primitive Data </p>
<p>Units </p>
<p>Data Type </p>
<p>Description  </p>
<p><br />
 </p>
<p>radiation_flux_* </p>
<p>W/m<sup>2</sup> </p>
<p> <font face="courier" color="green">float</font> </p>
<p>Absorbed radiation flux for band * (i.e., the flux for band 'PAR' would be 'radiation_flux_PAR').  </p>
<h1><a class="anchor" id="RadUse"></a>
Using the Radiation Model Plug-In</h1>
<h2><a class="anchor" id="RadConst"></a>
Model Class Constructor</h2>
<p>The radiation model class contains functions and data assoicated with the model. To begin, declare an instance of the <a class="el" href="class_radiation_model.html" title="Radiation transport model plugin. ">RadiationModel</a> class. The class constructor takes one argument - a pointer to the Helios context. It uses this pointer to access model geometry and data in the context.</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>RadiationModel radiationmodel(&amp;context); //declare the model class</code></pre></div><h2><a class="anchor" id="RadBands"></a>
Defining Wavelength Bands</h2>
<p>Arbitrary radiation wavelength bands can be added to the model, over which radiation calculations are performed. Each wavelength band is given a label that is defined by the user (e.g., 'PAR'). Each band has the possibility of having components of direct, diffuse, and emission, each of which are specified when adding the band. The <a class="el" href="class_radiation_model.html#a19ca27c9617fca821fa46a983bb31a1e">addRadiationBand()</a> command is used to add each band, which takes one argument, which is a user-defined label for the band (e.g, 'PAR').</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>radiationmodel.addRadiationBand( "PAR" ); //Add band 'PAR'</code></pre></div><h2><a class="anchor" id="RadProps"></a>
Radiative Properties</h2>
<p>Radiative properties (reflectivity, transmissivity, emissivity) are defined for each band each primitive. Their values are set via primitive data (see also Input Primitive Data table above, and <a class="el" href="classhelios_1_1_context.html#af5cd7c605339016dd06e2cae52deb32a">setPrimitiveData()</a>): <br />
 </p><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> <code></code>// Initialize the Context
 Context context;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> <code></code>// Add 'Patch' primitive
 vec3 center = make_vec3(0,0,1);
 vec2 size = make_vec2(1,1);
 uint UUID = context.addPatch( center, size );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> float rho = 0.1; //reflectivity value
 context.setPrimitiveData( UUID, "reflectivity_PAR", HELIOS_TYPE_FLOAT, 1, &amp;rho);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> float tau = 0.1; //transmissivity value
 context.setPrimitiveData( UUID, "transmissivity_PAR", HELIOS_TYPE_FLOAT, 1, &amp;tau);</code></pre></div><p>Note that absorptivity is not directly set, rather it is calculated as <img class="formulaInl" alt="$1-\rho-\tau$" src="form_52.png"/>. If <img class="formulaInl" alt="$1-\rho-\tau$" src="form_52.png"/> is calculated to be negative, an error is thrown.</p>
<h2><a class="anchor" id="RadEmission"></a>
Radiative Emission</h2>
<p>By default, radiation emission calculations are performed for each band. Each primitive emits radiation with a flux of <img class="formulaInl" alt="$\varepsilon \sigma T^4$" src="form_53.png"/>, where <img class="formulaInl" alt="$\varepsilon$" src="form_54.png"/> is the primitive's emissivity, <img class="formulaInl" alt="$\sigma=5.67\times 10^{-8}\,W/m^2/K^4$" src="form_55.png"/> is the Steffan Boltzmann constant, and <img class="formulaInl" alt="$T$" src="form_44.png"/> is the primitive's surface temperature in Kelvin. By default, it is assumed that <img class="formulaInl" alt="$\varepsilon=1$" src="form_56.png"/>, unless primitive data exists that defines the emissivity. By default, it is also assumed that <img class="formulaInl" alt="$T=300K$" src="form_57.png"/>, unless the primitive data 'temperature' exists in the Context whose value defines the temperature.</p>
<p>Emission can be disabled for the band by caling the <a class="el" href="class_radiation_model.html#a45774805001673a42a94e5cd1e45be4c">disableEmission()</a> function. For example, for the photosynthetically active (PAR) band, terrestrial objects do not emit radiation (i.e., <img class="formulaInl" alt="$\varepsilon\approx 0$" src="form_58.png"/>) and thus rather than setting a zero emissivity for this band for all primitives, it is desirable to simply disable radiation emission for this band:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>radiationmodel.disableEmission( "PAR" ); //Disable emission for the 'PAR' band</code></pre></div><h3><a class="anchor" id="RadTwoSided"></a>
Single-Sided Emission and Absorption</h3>
<p>By default, a planar primitive will emit radiation from both faces. For primitives that only emit from one face (e.g., ground primitives), this default behavior should be modified. Single-sided emission can be achieved by setting primitive data for the particular primitive with a name of "twosided_flag" to a value of 0. Note that in this case radiation will be emitted from the side with its face in the direction of the primitive normal vector. If primitive data called "twosided_flag" is set to 1, this will produce the default behavior of emission from both faces.</p>
<p>A primitive with "twosided_flag" set to 0 will not absorb any radiation from the back face of the primitive, but it will attenuate radiation. So if a ray hits the back face, the ray trajectory will be terminated, but no energy will be deposited.</p>
<h2><a class="anchor" id="RadSources"></a>
External Radiation Sources</h2>
<p>There are three types of external sources of radiation that can be simulated: 1) a collimated radiation source (beams of radiation are approximately parallel), 2) ambient diffuse radiation, and 3) a point source.</p>
<h3><a class="anchor" id="ColSource"></a>
Adding Collimated Sources</h3>
<p>A collimated radiation source is defined by a unit vector pointing in the direction of the collimated source, and by the radiation flux emitted by the source normal to the direction of radiation propagation.</p>
<p>The radiation model also requires the specification of the number of rays per primitive to be used in the simulation (default is 100 rays per primitive). The more rays used in the simulation the more accurate the answer will be, but this will result in a longer simulation time.</p>
<p>Below is an example of adding a collimated source oriented in the direction of the sun, with a flux of 800 and using 200 rays per primitive:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>vec3 sun_dir(0,0,1);
uint SunSource = radiationmodel.addCollimatedRadiationSource( sun_dir ); //add the source, whose identifier is stored in the 'SunSource' variable
 radiationmodel.setSourceFlux(SunSource,"PAR",800); //set the flux of the source
 radiationmodel.setDirectRayCount("PAR",200); //set the ray count for sources </code></pre></div><h3><a class="anchor" id="PointSource"></a>
Adding Point Sources</h3>
<p>Adding point sources is similar to adding collimated sources. Point sources are added using the addPointRadiationSource() function, which takes an (x,y,z) location of the point source as its argument. This function returns a uint which specifies the identifier for the point source, similar to a collimated source. The flux emanating from the source can also be set using the source identifier.</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>vec3 sun_dir(0,0,1);
uint PointSource = radiationmodel.addPointRadiationSource( sun_dir ); //add the source, whose identifier is stored in the 'PointSource' variable
radiationmodel.setSourceFlux(PointSource,"PAR",800); //set the flux of the source
radiationmodel.setDirectRayCount("PAR",200); //set the ray count for sources</code></pre></div><h3><a class="anchor" id="AmbSource"></a>
Adding Diffuse/Ambient Sources</h3>
<p>An ambient radiation source is added simply by setting its flux value:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>radiationmodel.setDiffuseRadiationFlux("PAR",200.f); //set the flux</code></pre></div><p>The default is to use 100 diffuse rays per primitive, which can be set to a user-defined value using the following command:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>radiationmodel.setDiffuseRayCount("PAR",200); //set the number of rays</code></pre></div><p> <br />
 </p>
<h2><a class="anchor" id="RadScatter"></a>
Scattering Iterations</h2>
<p>If the reflectivity or tranmissivity are set to values greater than 0, scattering calculations are required to simulate the reflected or transmitted radiation transport. These scattering calculations are performed iteratively until there is no energy left to be scattered. The number of scattering iterations is defined using:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>radiationmodel.setScatteringDepth(5); //set the number of scattering iterations</code></pre></div><p> <br />
 </p>
<h2><a class="anchor" id="RadRun"></a>
Running Simulations</h2>
<p>Before simulations are run, we must update the context geometry within the radiation model using the <a class="el" href="class_radiation_model.html#a0f55795694c31a0568e606c73f9d945a">updateGeometry()</a> command. The geometry update can be somewhat costly, so it should only be done whenever geometry changes.</p>
<p>Simulations for each band are run separately via the <a class="el" href="class_radiation_model.html#a7f43a8453667e3314aef36d6b5c416ed">runBand()</a> command:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> radiationmodel.updateGeometry(); //build the context geometry in the radiation model</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> radiationmodel.runBand("PAR"); //run the model for the 'PAR' band</code></pre></div><p>The model will create several primitive data in the context with values set using simulation results (see Sect. "Output Primitive Data" above).</p>
<h2><a class="anchor" id="RadSolar"></a>
Integrating with the SolarPosition Plug-in</h2>
<p>A common task when using the radiation model is to integrate with the <a class="el" href="class_solar_position.html">SolarPosition</a> plug-in to set the position of a collimated radiation source (i.e., the sun), potentially at several different times of the day. In this case, one would initialize the <a class="el" href="class_solar_position.html">SolarPosition</a> and <a class="el" href="class_radiation_model.html" title="Radiation transport model plugin. ">RadiationModel</a> classes and set up relevant inputs, then execute a for-loop over each time of the day. For each time iteration, the current time is set in the Context, the direction of the sun is calculated for that particular time, then the sun direction is passed to the radiation model. An example is illustrated in the code below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
 #include "Visualizer.h"
 #include "SolarPosition.h"
 #include "RadiationModel.h"</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> using namespace helios;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> int main( void ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>//---- inputs ----//
    int UTC = 7;             //hours from UTC
    float latitude = 35.2;   //latitude in degrees
    float longitude = 124.3; //longitude in degrees
    Date date(1,6,2018);     //current date (June 1 2018)</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    float pressure = 101300; //atmospheric pressure (Pa)
    float temperature = 300; //air temperature (K)
    float humidity = 0.5;    //relative humidity (-)
    float turbidity = 0.05;  //atmospheric turbidity coeff (-)
    <code></code>//----------------//</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>// --- 1. Initialize the Context and some geometry --- //
    Context context; //Initialize Context</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>// add some geometry
    context.addTile( make_vec3(0,0,0), make_vec2(10,10), make_SphericalCoord(0,0), make_int2(500,500) );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    context.addSphere( 50, make_vec3(0,0,2), 1 );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>// --- 2. Initialize the solar position model --- //</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    SolarPosition solarposition( UTC, latitude, longitude, &amp;context ); //initialize the solar position model</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>// --- 3. Initialize the radiation model --- //</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    RadiationModel radiationmodel( &amp;context ); //initialize the radiation model</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    uint SunSource = radiationmodel.addCollimatedRadiationSource(); //add the source (sun), we'll set it's direction later</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    radiationmodel.addRadiationBand("SW");
    radiationmodel.setDirectRayCount("SW",1000); //set the ray count for source
    radiationmodel.disableEmission("SW");</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    radiationmodel.updateGeometry();</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    <code></code>// --- 4. Loop over various hours of the day (7:00 thru 21:00) --- //</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    context.setDate( date ); //set the date, which will not change</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    for( int hour=7; hour&lt;22; hour++ ){</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       <code></code>// --- 5. Set the current time and calculate the associated sun direction --- //</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       context.setTime(0,hour); //set the current time for this iteration</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       <code></code>//Set the correct sun position for the current date, time, latitude, etc.
       vec3 sdir = solarposition.getSunDirectionVector(); //get the solar direction from plug-in
       radiationmodel.setSourcePosition( SunSource, sdir ); //set the radiation source direction in radiation model</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       <code></code>// --- 6. Calculate incoming solar fluxes for the current time --- //</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       <code></code>//Calculate the clear-sky direct and diffuse solar flux for the current date, time, latitude, etc.
       float Rflux = solarposition.getSolarFlux( pressure, temperature, humidity, turbidity );
       float fdiff = solarposition.getDiffuseFraction( pressure, temperature, humidity, turbidity ); //fraction of Rflux that is diffuse
       radiationmodel.setSourceFlux( SunSource, "SW", Rflux*(1-fdiff) ); //set the direct flux: Rflux*(1-fdiff)
       radiationmodel.setDiffuseRadiationFlux( "SW", Rflux*fdiff ); //set the diffuse flux: Rflux*fdiff</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       <code></code>// --- 7. Run the model --- //
       radiationmodel.runBand("SW");</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       <code></code>// --- 8. Visualize the result --- //</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       Visualizer vis(1000); //Initialize the visualizer</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       vis.buildContextGeometry(&amp;context); //add all geometry in the Context to the visualizer
       vis.colorContextPrimitivesByData( "radiation_flux_SW" ); //tell the visualizer to color based on radiation flux (primitive data)</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       vis.plotUpdate(); //plot the result</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       vis.printWindow(); //print to JPEG image</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       helios::wait(3); //wait for 3 seconds</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>       vis.closeWindow(); //close the window, then continue to next loop iteration</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    }//end loop over time</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code>    return 0;</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> }</code></pre></div><h2><a class="anchor" id="RadVis"></a>
Visualizing Model Outputs</h2>
<p>Visualization of radiation model outputs is typically achieved by coloring primitives based on the value of the primitive data "radiation_flux_*" for a particular band. However, we could visualize any input or output of the model or calculated value based on the model outputs.</p>
<p>A simple example of visualization of the absorbed flux for band "PAR" is given below, which assumes that a band exists named "PAR" and the model was run for that band.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> Visualizer vis(1000);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> vis.buildContextGeometry( &amp;context );
 vis.colorContextPrimitivesByData("radiation_flux_PAR");
 vis.enableColorbar();</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> vis.plotInteractive();</code></pre></div><p>It could also be possible to visualize the net all-wave radiation flux by summing multiple band fluxes. The following example assumes that there are bands created in the model for shortwave radiation called "SW" and for longwave radiation called "LW", and that the model has been run for each of these bands.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> Visualizer vis(1000);</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> vis.buildContextGeometry( &amp;context );</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> std::vector&lt;float&gt; total_flux;
 std::vector&lt;uint&gt; allUUIDs = context.getAllUUIDs();
 for( size_t p=0; p&lt;allUUIDs.size(); p++ ){
     uint UUID = allUUIDs.at(p);
     float flux_SW, flux_LW;
     context.getPrimitiveData( UUID, "radiation_flux_SW", flux_SW );
     context.getPrimitiveData( UUID, "radiation_flux_LW", flux_LW );
     total_flux.push_back( flux_SW + flux_LW );
 }</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> vis.colorContextPrimitivesByValue( total_flux );
 vis.enableColorbar();</code></pre></div><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"><pre><code> vis.plotInteractive();</code></pre></div> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
